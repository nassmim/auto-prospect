{"version":3,"sources":["../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/app-render/manifests-singleton.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/app-render/encryption-utils.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/app-render/encryption.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/lib/format-server-error.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/shared/lib/is-plain-object.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/lib/is-error.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/lib/error-telemetry-utils.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/app-render/react-large-shell-error.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/app-render/create-error-handler.tsx","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/use-cache/constants.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/lib/lru-cache.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/lib/cache-handlers/default.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/use-cache/handlers.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/use-cache/use-cache-errors.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/shared/lib/utils/reflect-utils.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/request/search-params.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/lib/lazy-result.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/lib/picocolors.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/build/output/log.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/server/use-cache/use-cache-wrapper.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/node_modules/.pnpm/next%4016.1.1_%40babel%2Bcore%407.28.6_%40opentelemetry%2Bapi%401.9.0_react-dom%4019.2.3_react%4019.2.3__react%4019.2.3/node_modules/next/src/build/webpack/loaders/next-flight-loader/cache-wrapper.ts"],"sourcesContent":["import type { ActionManifest } from '../../build/webpack/plugins/flight-client-entry-plugin'\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\nimport type { DeepReadonly } from '../../shared/lib/deep-readonly'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { normalizeAppPath } from '../../shared/lib/router/utils/app-paths'\nimport { pathHasPrefix } from '../../shared/lib/router/utils/path-has-prefix'\nimport { removePathPrefix } from '../../shared/lib/router/utils/remove-path-prefix'\nimport { workAsyncStorage } from './work-async-storage.external'\n\nexport interface ServerModuleMap {\n  readonly [name: string]: {\n    readonly id: string | number\n    readonly name: string\n    readonly chunks: Readonly<Array<string>> // currently not used\n    readonly async?: boolean\n  }\n}\n\n// This is a global singleton that is, among other things, also used to\n// encode/decode bound args of server function closures. This can't be using a\n// AsyncLocalStorage as it might happen at the module level.\nconst MANIFESTS_SINGLETON = Symbol.for('next.server.manifests')\n\ninterface ManifestsSingleton {\n  readonly clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n  readonly proxiedClientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n  serverModuleMap: ServerModuleMap\n}\n\ntype GlobalThisWithManifests = typeof globalThis & {\n  [MANIFESTS_SINGLETON]?: ManifestsSingleton\n}\n\ntype ClientReferenceManifestMappingProp =\n  | 'clientModules'\n  | 'rscModuleMapping'\n  | 'edgeRscModuleMapping'\n  | 'ssrModuleMapping'\n  | 'edgeSSRModuleMapping'\n\nconst globalThisWithManifests = globalThis as GlobalThisWithManifests\n\nfunction createProxiedClientReferenceManifest(\n  clientReferenceManifestsPerRoute: Map<\n    string,\n    DeepReadonly<ClientReferenceManifest>\n  >\n): DeepReadonly<ClientReferenceManifest> {\n  const createMappingProxy = (prop: ClientReferenceManifestMappingProp) => {\n    return new Proxy(\n      {},\n      {\n        get(_, id: string) {\n          const workStore = workAsyncStorage.getStore()\n\n          if (workStore) {\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (currentManifest?.[prop][id]) {\n              return currentManifest[prop][id]\n            }\n\n            // In development, we also check all other manifests to see if the\n            // module exists there. This is to support a scenario where React's\n            // I/O tracking (dev-only) creates a connection from one page to\n            // another through an emitted async I/O node that references client\n            // components from the other page, e.g. in owner props.\n            // TODO: Maybe we need to add a `debugBundlerConfig` option to React\n            // to avoid this workaround. The current workaround has the\n            // disadvantage that one might accidentally or intentionally share\n            // client references across pages (e.g. by storing them in a global\n            // variable), which would then only be caught in production.\n            if (process.env.NODE_ENV !== 'production') {\n              for (const [\n                route,\n                manifest,\n              ] of clientReferenceManifestsPerRoute) {\n                if (route === workStore.route) {\n                  continue\n                }\n\n                const entry = manifest[prop][id]\n\n                if (entry !== undefined) {\n                  return entry\n                }\n              }\n            }\n          } else {\n            // If there's no work store defined, we can assume that a client\n            // reference manifest is needed during module evaluation, e.g. to\n            // create a server function using a higher-order function. This\n            // might also use client components which need to be serialized by\n            // Flight, and therefore client references need to be resolvable. In\n            // that case we search all page manifests to find the module.\n            for (const manifest of clientReferenceManifestsPerRoute.values()) {\n              const entry = manifest[prop][id]\n\n              if (entry !== undefined) {\n                return entry\n              }\n            }\n          }\n\n          return undefined\n        },\n      }\n    )\n  }\n\n  const mappingProxies = new Map<\n    ClientReferenceManifestMappingProp,\n    ReturnType<typeof createMappingProxy>\n  >()\n\n  return new Proxy(\n    {},\n    {\n      get(_, prop) {\n        const workStore = workAsyncStorage.getStore()\n\n        switch (prop) {\n          case 'moduleLoading':\n          case 'entryCSSFiles':\n          case 'entryJSFiles': {\n            if (!workStore) {\n              throw new InvariantError(\n                `Cannot access \"${prop}\" without a work store.`\n              )\n            }\n\n            const currentManifest = clientReferenceManifestsPerRoute.get(\n              workStore.route\n            )\n\n            if (!currentManifest) {\n              throw new InvariantError(\n                `The client reference manifest for route \"${workStore.route}\" does not exist.`\n              )\n            }\n\n            return currentManifest[prop]\n          }\n          case 'clientModules':\n          case 'rscModuleMapping':\n          case 'edgeRscModuleMapping':\n          case 'ssrModuleMapping':\n          case 'edgeSSRModuleMapping': {\n            let proxy = mappingProxies.get(prop)\n\n            if (!proxy) {\n              proxy = createMappingProxy(prop)\n              mappingProxies.set(prop, proxy)\n            }\n\n            return proxy\n          }\n          default: {\n            throw new InvariantError(\n              `This is a proxied client reference manifest. The property \"${String(prop)}\" is not handled.`\n            )\n          }\n        }\n      },\n    }\n  ) as DeepReadonly<ClientReferenceManifest>\n}\n\n/**\n * This function creates a Flight-acceptable server module map proxy from our\n * Server Reference Manifest similar to our client module map. This is because\n * our manifest contains a lot of internal Next.js data that are relevant to the\n * runtime, workers, etc. that React doesn't need to know.\n */\nfunction createServerModuleMap(): ServerModuleMap {\n  return new Proxy(\n    {},\n    {\n      get: (_, id: string) => {\n        const workers =\n          getServerActionsManifest()[\n            process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n          ]?.[id]?.workers\n\n        if (!workers) {\n          return undefined\n        }\n\n        const workStore = workAsyncStorage.getStore()\n\n        let workerEntry:\n          | { moduleId: string | number; async: boolean }\n          | undefined\n\n        if (workStore) {\n          workerEntry = workers[normalizeWorkerPageName(workStore.page)]\n        } else {\n          // If there's no work store defined, we can assume that a server\n          // module map is needed during module evaluation, e.g. to create a\n          // server action using a higher-order function. Therefore it should be\n          // safe to return any entry from the manifest that matches the action\n          // ID. They all refer to the same module ID, which must also exist in\n          // the current page bundle. TODO: This is currently not guaranteed in\n          // Turbopack, and needs to be fixed.\n          workerEntry = Object.values(workers).at(0)\n        }\n\n        if (!workerEntry) {\n          return undefined\n        }\n\n        const { moduleId, async } = workerEntry\n\n        return { id: moduleId, name: id, chunks: [], async }\n      },\n    }\n  )\n}\n\n/**\n * The flight entry loader keys actions by bundlePath. bundlePath corresponds\n * with the relative path (including 'app') to the page entrypoint.\n */\nfunction normalizeWorkerPageName(pageName: string) {\n  if (pathHasPrefix(pageName, 'app')) {\n    return pageName\n  }\n\n  return 'app' + pageName\n}\n\n/**\n * Converts a bundlePath (relative path to the entrypoint) to a routable page\n * name.\n */\nfunction denormalizeWorkerPageName(bundlePath: string) {\n  return normalizeAppPath(removePathPrefix(bundlePath, 'app'))\n}\n\n/**\n * Checks if the requested action has a worker for the current page.\n * If not, it returns the first worker that has a handler for the action.\n */\nexport function selectWorkerForForwarding(\n  actionId: string,\n  pageName: string\n): string | undefined {\n  const serverActionsManifest = getServerActionsManifest()\n  const workers =\n    serverActionsManifest[\n      process.env.NEXT_RUNTIME === 'edge' ? 'edge' : 'node'\n    ][actionId]?.workers\n\n  // There are no workers to handle this action, nothing to forward to.\n  if (!workers) {\n    return\n  }\n\n  // If there is an entry for the current page, we don't need to forward.\n  if (workers[normalizeWorkerPageName(pageName)]) {\n    return\n  }\n\n  // Otherwise, grab the first worker that has a handler for this action id.\n  return denormalizeWorkerPageName(Object.keys(workers)[0])\n}\n\nexport function setManifestsSingleton({\n  page,\n  clientReferenceManifest,\n  serverActionsManifest,\n}: {\n  page: string\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>\n  serverActionsManifest: DeepReadonly<ActionManifest>\n}) {\n  const existingSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (existingSingleton) {\n    existingSingleton.clientReferenceManifestsPerRoute.set(\n      normalizeAppPath(page),\n      clientReferenceManifest\n    )\n\n    existingSingleton.serverActionsManifest = serverActionsManifest\n  } else {\n    const clientReferenceManifestsPerRoute = new Map<\n      string,\n      DeepReadonly<ClientReferenceManifest>\n    >([[normalizeAppPath(page), clientReferenceManifest]])\n\n    const proxiedClientReferenceManifest = createProxiedClientReferenceManifest(\n      clientReferenceManifestsPerRoute\n    )\n\n    globalThisWithManifests[MANIFESTS_SINGLETON] = {\n      clientReferenceManifestsPerRoute,\n      proxiedClientReferenceManifest,\n      serverActionsManifest,\n      serverModuleMap: createServerModuleMap(),\n    }\n  }\n}\n\nfunction getManifestsSingleton(): ManifestsSingleton {\n  const manifestSingleton = globalThisWithManifests[MANIFESTS_SINGLETON]\n\n  if (!manifestSingleton) {\n    throw new InvariantError('The manifests singleton was not initialized.')\n  }\n\n  return manifestSingleton\n}\n\nexport function getClientReferenceManifest(): DeepReadonly<ClientReferenceManifest> {\n  return getManifestsSingleton().proxiedClientReferenceManifest\n}\n\nexport function getServerActionsManifest(): DeepReadonly<ActionManifest> {\n  return getManifestsSingleton().serverActionsManifest\n}\n\nexport function getServerModuleMap() {\n  return getManifestsSingleton().serverModuleMap\n}\n","import { InvariantError } from '../../shared/lib/invariant-error'\nimport { getServerActionsManifest } from './manifests-singleton'\n\nlet __next_loaded_action_key: CryptoKey\n\nexport function arrayBufferToString(\n  buffer: ArrayBuffer | Uint8Array<ArrayBufferLike>\n) {\n  const bytes = new Uint8Array(buffer)\n  const len = bytes.byteLength\n\n  // @anonrig: V8 has a limit of 65535 arguments in a function.\n  // For len < 65535, this is faster.\n  // https://github.com/vercel/next.js/pull/56377#pullrequestreview-1656181623\n  if (len < 65535) {\n    return String.fromCharCode.apply(null, bytes as unknown as number[])\n  }\n\n  let binary = ''\n  for (let i = 0; i < len; i++) {\n    binary += String.fromCharCode(bytes[i])\n  }\n  return binary\n}\n\nexport function stringToUint8Array(binary: string) {\n  const len = binary.length\n  const arr = new Uint8Array(len)\n\n  for (let i = 0; i < len; i++) {\n    arr[i] = binary.charCodeAt(i)\n  }\n\n  return arr\n}\n\nexport function encrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.encrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport function decrypt(\n  key: CryptoKey,\n  iv: Uint8Array<ArrayBuffer>,\n  data: Uint8Array<ArrayBuffer>\n) {\n  return crypto.subtle.decrypt(\n    {\n      name: 'AES-GCM',\n      iv,\n    },\n    key,\n    data\n  )\n}\n\nexport async function getActionEncryptionKey() {\n  if (__next_loaded_action_key) {\n    return __next_loaded_action_key\n  }\n\n  const serverActionsManifest = getServerActionsManifest()\n\n  const rawKey =\n    process.env.NEXT_SERVER_ACTIONS_ENCRYPTION_KEY ||\n    serverActionsManifest.encryptionKey\n\n  if (rawKey === undefined) {\n    throw new InvariantError('Missing encryption key for Server Actions')\n  }\n\n  __next_loaded_action_key = await crypto.subtle.importKey(\n    'raw',\n    stringToUint8Array(atob(rawKey)),\n    'AES-GCM',\n    true,\n    ['encrypt', 'decrypt']\n  )\n\n  return __next_loaded_action_key\n}\n","/* eslint-disable import/no-extraneous-dependencies */\nimport 'server-only'\n\n/* eslint-disable import/no-extraneous-dependencies */\nimport { renderToReadableStream } from 'react-server-dom-webpack/server'\n/* eslint-disable import/no-extraneous-dependencies */\nimport { createFromReadableStream } from 'react-server-dom-webpack/client'\n\nimport { streamToString } from '../stream-utils/node-web-streams-helper'\nimport {\n  arrayBufferToString,\n  decrypt,\n  encrypt,\n  getActionEncryptionKey,\n  stringToUint8Array,\n} from './encryption-utils'\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from './manifests-singleton'\nimport {\n  getCacheSignal,\n  getPrerenderResumeDataCache,\n  getRenderResumeDataCache,\n  workUnitAsyncStorage,\n} from './work-unit-async-storage.external'\nimport { createHangingInputAbortSignal } from './dynamic-rendering'\nimport React from 'react'\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst textEncoder = new TextEncoder()\nconst textDecoder = new TextDecoder()\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\n/**\n * Decrypt the serialized string with the action id as the salt.\n */\nasync function decodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (typeof key === 'undefined') {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get the iv (16 bytes) and the payload from the arg.\n  const originalPayload = atob(arg)\n  const ivValue = originalPayload.slice(0, 16)\n  const payload = originalPayload.slice(16)\n\n  const decrypted = textDecoder.decode(\n    await decrypt(key, stringToUint8Array(ivValue), stringToUint8Array(payload))\n  )\n\n  if (!decrypted.startsWith(actionId)) {\n    throw new Error('Invalid Server Action payload: failed to decrypt.')\n  }\n\n  return decrypted.slice(actionId.length)\n}\n\n/**\n * Encrypt the serialized string with the action id as the salt. Add a prefix to\n * later ensure that the payload is correctly decrypted, similar to a checksum.\n */\nasync function encodeActionBoundArg(actionId: string, arg: string) {\n  const key = await getActionEncryptionKey()\n  if (key === undefined) {\n    throw new Error(\n      `Missing encryption key for Server Action. This is a bug in Next.js`\n    )\n  }\n\n  // Get 16 random bytes as iv.\n  const randomBytes = new Uint8Array(16)\n  workUnitAsyncStorage.exit(() => crypto.getRandomValues(randomBytes))\n  const ivValue = arrayBufferToString(randomBytes.buffer)\n\n  const encrypted = await encrypt(\n    key,\n    randomBytes,\n    textEncoder.encode(actionId + arg)\n  )\n\n  return btoa(ivValue + arrayBufferToString(encrypted))\n}\n\nenum ReadStatus {\n  Ready,\n  Pending,\n  Complete,\n}\n\n// Encrypts the action's bound args into a string. For the same combination of\n// actionId and args the same cached promise is returned. This ensures reference\n// equality for returned objects from \"use cache\" functions when they're invoked\n// multiple times within one render pass using the same bound args.\nexport const encryptActionBoundArgs = React.cache(\n  async function encryptActionBoundArgs(actionId: string, ...args: any[]) {\n    const workUnitStore = workUnitAsyncStorage.getStore()\n    const cacheSignal = workUnitStore\n      ? getCacheSignal(workUnitStore)\n      : undefined\n\n    const { clientModules } = getClientReferenceManifest()\n\n    // Create an error before any asynchronous calls, to capture the original\n    // call stack in case we need it when the serialization errors.\n    const error = new Error()\n    Error.captureStackTrace(error, encryptActionBoundArgs)\n\n    let didCatchError = false\n\n    const hangingInputAbortSignal = workUnitStore\n      ? createHangingInputAbortSignal(workUnitStore)\n      : undefined\n\n    let readStatus = ReadStatus.Ready\n    function startReadOnce() {\n      if (readStatus === ReadStatus.Ready) {\n        readStatus = ReadStatus.Pending\n        cacheSignal?.beginRead()\n      }\n    }\n\n    function endReadIfStarted() {\n      if (readStatus === ReadStatus.Pending) {\n        cacheSignal?.endRead()\n      }\n      readStatus = ReadStatus.Complete\n    }\n\n    // streamToString might take longer than a microtask to resolve and then other things\n    // waiting on the cache signal might not realize there is another cache to fill so if\n    // we are no longer waiting on the bound args serialization via the hangingInputAbortSignal\n    // we should eagerly start the cache read to prevent other readers of the cache signal from\n    // missing this cache fill. We use a idempotent function to only start reading once because\n    // it's also possible that streamToString finishes before the hangingInputAbortSignal aborts.\n    if (hangingInputAbortSignal && cacheSignal) {\n      hangingInputAbortSignal.addEventListener('abort', startReadOnce, {\n        once: true,\n      })\n    }\n\n    // Using Flight to serialize the args into a string.\n    const serialized = await streamToString(\n      renderToReadableStream(args, clientModules, {\n        filterStackFrame,\n        signal: hangingInputAbortSignal,\n        onError(err) {\n          if (hangingInputAbortSignal?.aborted) {\n            return\n          }\n\n          // We're only reporting one error at a time, starting with the first.\n          if (didCatchError) {\n            return\n          }\n\n          didCatchError = true\n\n          // Use the original error message together with the previously created\n          // stack, because err.stack is a useless Flight Server call stack.\n          error.message = err instanceof Error ? err.message : String(err)\n        },\n      }),\n      // We pass the abort signal to `streamToString` so that no chunks are\n      // included that are emitted after the signal was already aborted. This\n      // ensures that we can encode hanging promises.\n      hangingInputAbortSignal\n    )\n\n    if (didCatchError) {\n      if (process.env.NODE_ENV === 'development') {\n        // Logging the error is needed for server functions that are passed to the\n        // client where the decryption is not done during rendering. Console\n        // replaying allows us to still show the error dev overlay in this case.\n        console.error(error)\n      }\n\n      endReadIfStarted()\n      throw error\n    }\n\n    if (!workUnitStore) {\n      // We don't need to call cacheSignal.endRead here because we can't have a cacheSignal\n      // if we do not have a workUnitStore.\n      return encodeActionBoundArg(actionId, serialized)\n    }\n\n    startReadOnce()\n\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n    const cacheKey = actionId + serialized\n\n    const cachedEncrypted =\n      prerenderResumeDataCache?.encryptedBoundArgs.get(cacheKey) ??\n      renderResumeDataCache?.encryptedBoundArgs.get(cacheKey)\n\n    if (cachedEncrypted) {\n      return cachedEncrypted\n    }\n\n    const encrypted = await encodeActionBoundArg(actionId, serialized)\n\n    endReadIfStarted()\n    prerenderResumeDataCache?.encryptedBoundArgs.set(cacheKey, encrypted)\n\n    return encrypted\n  }\n)\n\n// Decrypts the action's bound args from the encrypted string.\nexport async function decryptActionBoundArgs(\n  actionId: string,\n  encryptedPromise: Promise<string>\n) {\n  const encrypted = await encryptedPromise\n  const workUnitStore = workUnitAsyncStorage.getStore()\n\n  let decrypted: string | undefined\n\n  if (workUnitStore) {\n    const cacheSignal = getCacheSignal(workUnitStore)\n    const prerenderResumeDataCache = getPrerenderResumeDataCache(workUnitStore)\n    const renderResumeDataCache = getRenderResumeDataCache(workUnitStore)\n\n    decrypted =\n      prerenderResumeDataCache?.decryptedBoundArgs.get(encrypted) ??\n      renderResumeDataCache?.decryptedBoundArgs.get(encrypted)\n\n    if (!decrypted) {\n      cacheSignal?.beginRead()\n      decrypted = await decodeActionBoundArg(actionId, encrypted)\n      cacheSignal?.endRead()\n      prerenderResumeDataCache?.decryptedBoundArgs.set(encrypted, decrypted)\n    }\n  } else {\n    decrypted = await decodeActionBoundArg(actionId, encrypted)\n  }\n\n  const { edgeRscModuleMapping, rscModuleMapping } =\n    getClientReferenceManifest()\n\n  // Using Flight to deserialize the args from the string.\n  const deserialized = await createFromReadableStream(\n    new ReadableStream({\n      start(controller) {\n        controller.enqueue(textEncoder.encode(decrypted))\n\n        switch (workUnitStore?.type) {\n          case 'prerender':\n          case 'prerender-runtime':\n            // Explicitly don't close the stream here (until prerendering is\n            // complete) so that hanging promises are not rejected.\n            if (workUnitStore.renderSignal.aborted) {\n              controller.close()\n            } else {\n              workUnitStore.renderSignal.addEventListener(\n                'abort',\n                () => controller.close(),\n                { once: true }\n              )\n            }\n            break\n          case 'prerender-client':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n          case undefined:\n            return controller.close()\n          default:\n            workUnitStore satisfies never\n        }\n      },\n    }),\n    {\n      findSourceMapURL,\n      serverConsumerManifest: {\n        // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n        // to be added to the current execution. Instead, we'll wait for any ClientReference\n        // to be emitted which themselves will handle the preloading.\n        moduleLoading: null,\n        moduleMap: isEdgeRuntime ? edgeRscModuleMapping : rscModuleMapping,\n        serverModuleMap: getServerModuleMap(),\n      },\n    }\n  )\n\n  return deserialized\n}\n","const invalidServerComponentReactHooks = [\n  'useDeferredValue',\n  'useEffect',\n  'useImperativeHandle',\n  'useInsertionEffect',\n  'useLayoutEffect',\n  'useReducer',\n  'useRef',\n  'useState',\n  'useSyncExternalStore',\n  'useTransition',\n  'experimental_useOptimistic',\n  'useOptimistic',\n]\n\nfunction setMessage(error: Error, message: string): void {\n  error.message = message\n  if (error.stack) {\n    const lines = error.stack.split('\\n')\n    lines[0] = message\n    error.stack = lines.join('\\n')\n  }\n}\n\n/**\n * Input:\n * Error: Something went wrong\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10)\n \n * Output:\n    at funcName (/path/to/file.js:10:5)\n    at anotherFunc (/path/to/file.js:15:10) \n */\nexport function getStackWithoutErrorMessage(error: Error): string {\n  const stack = error.stack\n  if (!stack) return ''\n  return stack.replace(/^[^\\n]*\\n/, '')\n}\n\nexport function formatServerError(error: Error): void {\n  if (typeof error?.message !== 'string') return\n\n  if (\n    error.message.includes(\n      'Class extends value undefined is not a constructor or null'\n    )\n  ) {\n    const addedMessage =\n      'This might be caused by a React Class Component being rendered in a Server Component, React Class Components only works in Client Components. Read more: https://nextjs.org/docs/messages/class-component-in-server-component'\n\n    // If this error instance already has the message, don't add it again\n    if (error.message.includes(addedMessage)) return\n\n    setMessage(\n      error,\n      `${error.message}\n\n${addedMessage}`\n    )\n    return\n  }\n\n  if (error.message.includes('createContext is not a function')) {\n    setMessage(\n      error,\n      'createContext only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/context-in-server-component'\n    )\n    return\n  }\n\n  for (const clientHook of invalidServerComponentReactHooks) {\n    const regex = new RegExp(`\\\\b${clientHook}\\\\b.*is not a function`)\n    if (regex.test(error.message)) {\n      setMessage(\n        error,\n        `${clientHook} only works in Client Components. Add the \"use client\" directive at the top of the file to use it. Read more: https://nextjs.org/docs/messages/react-client-hook-in-server-component`\n      )\n      return\n    }\n  }\n}\n","export function getObjectClassLabel(value: any): string {\n  return Object.prototype.toString.call(value)\n}\n\nexport function isPlainObject(value: any): boolean {\n  if (getObjectClassLabel(value) !== '[object Object]') {\n    return false\n  }\n\n  const prototype = Object.getPrototypeOf(value)\n\n  /**\n   * this used to be previously:\n   *\n   * `return prototype === null || prototype === Object.prototype`\n   *\n   * but Edge Runtime expose Object from vm, being that kind of type-checking wrongly fail.\n   *\n   * It was changed to the current implementation since it's resilient to serialization.\n   */\n  return prototype === null || prototype.hasOwnProperty('isPrototypeOf')\n}\n","import { isPlainObject } from '../shared/lib/is-plain-object'\n\n// We allow some additional attached properties for Next.js errors\nexport interface NextError extends Error {\n  type?: string\n  page?: string\n  code?: string | number\n  cancelled?: boolean\n  digest?: number\n}\n\n/**\n * This is a safe stringify function that handles circular references.\n * We're using a simpler version here to avoid introducing\n * the dependency `safe-stable-stringify` into production bundle.\n *\n * This helper is used both in development and production.\n */\nfunction safeStringifyLite(obj: any) {\n  const seen = new WeakSet()\n\n  return JSON.stringify(obj, (_key, value) => {\n    // If value is an object and already seen, replace with \"[Circular]\"\n    if (typeof value === 'object' && value !== null) {\n      if (seen.has(value)) {\n        return '[Circular]'\n      }\n      seen.add(value)\n    }\n    return value\n  })\n}\n\n/**\n * Checks whether the given value is a NextError.\n * This can be used to print a more detailed error message with properties like `code` & `digest`.\n */\nexport default function isError(err: unknown): err is NextError {\n  return (\n    typeof err === 'object' && err !== null && 'name' in err && 'message' in err\n  )\n}\n\nexport function getProperError(err: unknown): Error {\n  if (isError(err)) {\n    return err\n  }\n\n  if (process.env.NODE_ENV === 'development') {\n    // provide better error for case where `throw undefined`\n    // is called in development\n    if (typeof err === 'undefined') {\n      return new Error(\n        'An undefined error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n\n    if (err === null) {\n      return new Error(\n        'A null error was thrown, ' +\n          'see here for more info: https://nextjs.org/docs/messages/threw-undefined'\n      )\n    }\n  }\n\n  return new Error(isPlainObject(err) ? safeStringifyLite(err) : err + '')\n}\n","const ERROR_CODE_DELIMITER = '@'\n\n/**\n * Augments the digest field of errors thrown in React Server Components (RSC) with an error code.\n * Since RSC errors can only be serialized through the digest field, this provides a way to include\n * an additional error code that can be extracted client-side via `extractNextErrorCode`.\n *\n * The error code is appended to the digest string with a semicolon separator, allowing it to be\n * parsed out later while preserving the original digest value.\n */\nexport const createDigestWithErrorCode = (\n  thrownValue: unknown,\n  originalDigest: string\n): string => {\n  if (\n    typeof thrownValue === 'object' &&\n    thrownValue !== null &&\n    '__NEXT_ERROR_CODE' in thrownValue\n  ) {\n    return `${originalDigest}${ERROR_CODE_DELIMITER}${thrownValue.__NEXT_ERROR_CODE}`\n  }\n  return originalDigest\n}\n\nexport const extractNextErrorCode = (error: unknown): string | undefined => {\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    '__NEXT_ERROR_CODE' in error &&\n    typeof error.__NEXT_ERROR_CODE === 'string'\n  ) {\n    return error.__NEXT_ERROR_CODE\n  }\n\n  if (\n    typeof error === 'object' &&\n    error !== null &&\n    'digest' in error &&\n    typeof error.digest === 'string'\n  ) {\n    const segments = error.digest.split(ERROR_CODE_DELIMITER)\n    const errorCode = segments.find((segment) => segment.startsWith('E'))\n    return errorCode\n  }\n\n  return undefined\n}\n","// TODO: isWellKnownError -> isNextInternalError\n// isReactLargeShellError -> isWarning\nexport function isReactLargeShellError(\n  error: unknown\n): error is Error & { digest?: string } {\n  return (\n    typeof error === 'object' &&\n    error !== null &&\n    'message' in error &&\n    typeof error.message === 'string' &&\n    error.message.startsWith('This rendered a large document (>')\n  )\n}\n","import type { ErrorInfo } from 'react'\nimport stringHash from 'next/dist/compiled/string-hash'\n\nimport { formatServerError } from '../../lib/format-server-error'\nimport { SpanStatusCode, getTracer } from '../lib/trace/tracer'\n\nimport { isAbortError } from '../pipe-readable'\nimport { isBailoutToCSRError } from '../../shared/lib/lazy-dynamic/bailout-to-csr'\nimport { isDynamicServerError } from '../../client/components/hooks-server-context'\nimport { isNextRouterError } from '../../client/components/is-next-router-error'\nimport { isPrerenderInterruptedError } from './dynamic-rendering'\nimport { getProperError } from '../../lib/is-error'\nimport { createDigestWithErrorCode } from '../../lib/error-telemetry-utils'\nimport { isReactLargeShellError } from './react-large-shell-error'\n\ndeclare global {\n  var __next_log_error__: undefined | ((err: unknown) => void)\n}\n\ntype RSCErrorHandler = (err: unknown) => string | undefined\ntype SSRErrorHandler = (\n  err: unknown,\n  errorInfo?: ErrorInfo\n) => string | undefined\n\nexport type DigestedError = Error & { digest: string; environmentName?: string }\n\n/**\n * Returns a digest for well-known Next.js errors, otherwise `undefined`. If a\n * digest is returned this also means that the error does not need to be\n * reported.\n */\nexport function getDigestForWellKnownError(error: unknown): string | undefined {\n  // If we're bailing out to CSR, we don't need to log the error.\n  if (isBailoutToCSRError(error)) return error.digest\n\n  // If this is a navigation error, we don't need to log the error.\n  if (isNextRouterError(error)) return error.digest\n\n  // If this error occurs, we know that we should be stopping the static\n  // render. This is only thrown in static generation when PPR is not enabled,\n  // which causes the whole page to be marked as dynamic. We don't need to\n  // tell the user about this error, as it's not actionable.\n  if (isDynamicServerError(error)) return error.digest\n\n  // If this is a prerender interrupted error, we don't need to log the error.\n  if (isPrerenderInterruptedError(error)) return error.digest\n\n  return undefined\n}\n\nexport function createReactServerErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  onReactServerRenderError: (err: DigestedError, silenceLog: boolean) => void,\n  spanToRecordOn?: any\n): RSCErrorHandler {\n  return (thrownValue: unknown) => {\n    if (typeof thrownValue === 'string') {\n      // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n      return stringHash(thrownValue).toString()\n    }\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let err = getProperError(thrownValue) as DigestedError\n    let silenceLog = false\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (\n        process.env.NODE_ENV === 'production' &&\n        reactServerErrors.has(err.digest)\n      ) {\n        // This error is likely an obfuscated error from another react-server\n        // environment (e.g. 'use cache'). We recover the original error here\n        // for reporting purposes.\n        err = reactServerErrors.get(err.digest)!\n        // We don't log it again though, as it was already logged in the\n        // original environment.\n        silenceLog = true\n      } else {\n        // Either we're in development (where we want to keep the transported\n        // error with environmentName), or the error is not in reactServerErrors\n        // but has a digest from other means. Keep the error as-is.\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        // TODO-APP: look at using webcrypto instead. Requires a promise to be awaited.\n        stringHash(err.message + (err.stack || '')).toString()\n      )\n    }\n\n    // @TODO by putting this here and not at the top it is possible that\n    // we don't error the build in places we actually expect to\n    if (!reactServerErrors.has(err.digest)) {\n      reactServerErrors.set(err.digest, err)\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // Record exception on the provided span if available, otherwise try active span.\n      const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n      if (span) {\n        span.recordException(err)\n        span.setAttribute('error.type', err.name)\n        span.setStatus({\n          code: SpanStatusCode.ERROR,\n          message: err.message,\n        })\n      }\n\n      onReactServerRenderError(err, silenceLog)\n    }\n\n    return err.digest\n  }\n}\n\nexport function createHTMLErrorHandler(\n  shouldFormatError: boolean,\n  isNextExport: boolean,\n  reactServerErrors: Map<string, DigestedError>,\n  allCapturedErrors: Array<unknown>,\n  onHTMLRenderSSRError: (err: DigestedError, errorInfo?: ErrorInfo) => void,\n  spanToRecordOn?: any\n): SSRErrorHandler {\n  return (thrownValue: unknown, errorInfo?: ErrorInfo) => {\n    if (isReactLargeShellError(thrownValue)) {\n      // TODO: Aggregate\n      console.error(thrownValue)\n      return undefined\n    }\n\n    let isSSRError = true\n\n    allCapturedErrors.push(thrownValue)\n\n    // If the response was closed, we don't need to log the error.\n    if (isAbortError(thrownValue)) return\n\n    const digest = getDigestForWellKnownError(thrownValue)\n\n    if (digest) {\n      return digest\n    }\n\n    const err = getProperError(thrownValue) as DigestedError\n\n    // If the error already has a digest, respect the original digest,\n    // so it won't get re-generated into another new error.\n    if (err.digest) {\n      if (reactServerErrors.has(err.digest)) {\n        // This error is likely an obfuscated error from react-server.\n        // We recover the original error here.\n        thrownValue = reactServerErrors.get(err.digest)\n        isSSRError = false\n      } else {\n        // The error is not from react-server but has a digest\n        // from other means so we don't need to produce a new one\n      }\n    } else {\n      err.digest = createDigestWithErrorCode(\n        err,\n        stringHash(\n          err.message + (errorInfo?.componentStack || err.stack || '')\n        ).toString()\n      )\n    }\n\n    // Format server errors in development to add more helpful error messages\n    if (shouldFormatError) {\n      formatServerError(err)\n    }\n\n    // Don't log the suppressed error during export\n    if (\n      !(\n        isNextExport &&\n        err?.message?.includes(\n          'The specific message is omitted in production builds to avoid leaking sensitive details.'\n        )\n      )\n    ) {\n      // HTML errors contain RSC errors as well, filter them out before reporting\n      if (isSSRError) {\n        // Record exception on the provided span if available, otherwise try active span.\n        const span = spanToRecordOn ?? getTracer().getActiveScopeSpan()\n        if (span) {\n          span.recordException(err)\n          span.setAttribute('error.type', err.name)\n          span.setStatus({\n            code: SpanStatusCode.ERROR,\n            message: err.message,\n          })\n        }\n\n        onHTMLRenderSSRError(err, errorInfo)\n      }\n    }\n\n    return err.digest\n  }\n}\n\nexport function isUserLandError(err: any): boolean {\n  return (\n    !isAbortError(err) && !isBailoutToCSRError(err) && !isNextRouterError(err)\n  )\n}\n","export const DYNAMIC_EXPIRE = 300 // 5 minutes\nexport const RUNTIME_PREFETCH_DYNAMIC_STALE = 30 // 30 seconds\n","/**\n * Node in the doubly-linked list used for LRU tracking.\n * Each node represents a cache entry with bidirectional pointers.\n */\nclass LRUNode<T> {\n  public readonly key: string\n  public data: T\n  public size: number\n  public prev: LRUNode<T> | SentinelNode<T> | null = null\n  public next: LRUNode<T> | SentinelNode<T> | null = null\n\n  constructor(key: string, data: T, size: number) {\n    this.key = key\n    this.data = data\n    this.size = size\n  }\n}\n\n/**\n * Sentinel node used for head/tail boundaries.\n * These nodes don't contain actual cache data but simplify list operations.\n */\nclass SentinelNode<T> {\n  public prev: LRUNode<T> | SentinelNode<T> | null = null\n  public next: LRUNode<T> | SentinelNode<T> | null = null\n}\n\n/**\n * LRU (Least Recently Used) Cache implementation using a doubly-linked list\n * and hash map for O(1) operations.\n *\n * Algorithm:\n * - Uses a doubly-linked list to maintain access order (most recent at head)\n * - Hash map provides O(1) key-to-node lookup\n * - Sentinel head/tail nodes simplify edge case handling\n * - Size-based eviction supports custom size calculation functions\n *\n * Data Structure Layout:\n * HEAD <-> [most recent] <-> ... <-> [least recent] <-> TAIL\n *\n * Operations:\n * - get(): Move accessed node to head (mark as most recent)\n * - set(): Add new node at head, evict from tail if over capacity\n * - Eviction: Remove least recent node (tail.prev) when size exceeds limit\n */\nexport class LRUCache<T> {\n  private readonly cache: Map<string, LRUNode<T>> = new Map()\n  private readonly head: SentinelNode<T>\n  private readonly tail: SentinelNode<T>\n  private totalSize: number = 0\n  private readonly maxSize: number\n  private readonly calculateSize: ((value: T) => number) | undefined\n\n  constructor(maxSize: number, calculateSize?: (value: T) => number) {\n    this.maxSize = maxSize\n    this.calculateSize = calculateSize\n\n    // Create sentinel nodes to simplify doubly-linked list operations\n    // HEAD <-> TAIL (empty list)\n    this.head = new SentinelNode<T>()\n    this.tail = new SentinelNode<T>()\n    this.head.next = this.tail\n    this.tail.prev = this.head\n  }\n\n  /**\n   * Adds a node immediately after the head (marks as most recently used).\n   * Used when inserting new items or when an item is accessed.\n   * PRECONDITION: node must be disconnected (prev/next should be null)\n   */\n  private addToHead(node: LRUNode<T>): void {\n    node.prev = this.head\n    node.next = this.head.next\n    // head.next is always non-null (points to tail or another node)\n    this.head.next!.prev = node\n    this.head.next = node\n  }\n\n  /**\n   * Removes a node from its current position in the doubly-linked list.\n   * Updates the prev/next pointers of adjacent nodes to maintain list integrity.\n   * PRECONDITION: node must be connected (prev/next are non-null)\n   */\n  private removeNode(node: LRUNode<T>): void {\n    // Connected nodes always have non-null prev/next\n    node.prev!.next = node.next\n    node.next!.prev = node.prev\n  }\n\n  /**\n   * Moves an existing node to the head position (marks as most recently used).\n   * This is the core LRU operation - accessed items become most recent.\n   */\n  private moveToHead(node: LRUNode<T>): void {\n    this.removeNode(node)\n    this.addToHead(node)\n  }\n\n  /**\n   * Removes and returns the least recently used node (the one before tail).\n   * This is called during eviction when the cache exceeds capacity.\n   * PRECONDITION: cache is not empty (ensured by caller)\n   */\n  private removeTail(): LRUNode<T> {\n    const lastNode = this.tail.prev as LRUNode<T>\n    // tail.prev is always non-null and always LRUNode when cache is not empty\n    this.removeNode(lastNode)\n    return lastNode\n  }\n\n  /**\n   * Sets a key-value pair in the cache.\n   * If the key exists, updates the value and moves to head.\n   * If new, adds at head and evicts from tail if necessary.\n   *\n   * Time Complexity:\n   * - O(1) for uniform item sizes\n   * - O(k) where k is the number of items evicted (can be O(N) for variable sizes)\n   */\n  public set(key: string, value: T): void {\n    const size = this.calculateSize?.(value) ?? 1\n    if (size > this.maxSize) {\n      console.warn('Single item size exceeds maxSize')\n      return\n    }\n\n    const existing = this.cache.get(key)\n    if (existing) {\n      // Update existing node: adjust size and move to head (most recent)\n      existing.data = value\n      this.totalSize = this.totalSize - existing.size + size\n      existing.size = size\n      this.moveToHead(existing)\n    } else {\n      // Add new node at head (most recent position)\n      const newNode = new LRUNode(key, value, size)\n      this.cache.set(key, newNode)\n      this.addToHead(newNode)\n      this.totalSize += size\n    }\n\n    // Evict least recently used items until under capacity\n    while (this.totalSize > this.maxSize && this.cache.size > 0) {\n      const tail = this.removeTail()\n      this.cache.delete(tail.key)\n      this.totalSize -= tail.size\n    }\n  }\n\n  /**\n   * Checks if a key exists in the cache.\n   * This is a pure query operation - does NOT update LRU order.\n   *\n   * Time Complexity: O(1)\n   */\n  public has(key: string): boolean {\n    return this.cache.has(key)\n  }\n\n  /**\n   * Retrieves a value by key and marks it as most recently used.\n   * Moving to head maintains the LRU property for future evictions.\n   *\n   * Time Complexity: O(1)\n   */\n  public get(key: string): T | undefined {\n    const node = this.cache.get(key)\n    if (!node) return undefined\n\n    // Mark as most recently used by moving to head\n    this.moveToHead(node)\n\n    return node.data\n  }\n\n  /**\n   * Returns an iterator over the cache entries. The order is outputted in the\n   * order of most recently used to least recently used.\n   */\n  public *[Symbol.iterator](): IterableIterator<[string, T]> {\n    let current = this.head.next\n    while (current && current !== this.tail) {\n      // Between head and tail, current is always LRUNode\n      const node = current as LRUNode<T>\n      yield [node.key, node.data]\n      current = current.next\n    }\n  }\n\n  /**\n   * Removes a specific key from the cache.\n   * Updates both the hash map and doubly-linked list.\n   *\n   * Time Complexity: O(1)\n   */\n  public remove(key: string): void {\n    const node = this.cache.get(key)\n    if (!node) return\n\n    this.removeNode(node)\n    this.cache.delete(key)\n    this.totalSize -= node.size\n  }\n\n  /**\n   * Returns the number of items in the cache.\n   */\n  public get size(): number {\n    return this.cache.size\n  }\n\n  /**\n   * Returns the current total size of all cached items.\n   * This uses the custom size calculation if provided.\n   */\n  public get currentSize(): number {\n    return this.totalSize\n  }\n}\n","/**\n * This is the default \"use cache\" handler it defaults to an in-memory store.\n * In-memory caches are fragile and should not use stale-while-revalidate\n * semantics on the caches because it's not worth warming up an entry that's\n * likely going to get evicted before we get to use it anyway. However, we also\n * don't want to reuse a stale entry for too long so stale entries should be\n * considered expired/missing in such cache handlers.\n */\n\nimport { LRUCache } from '../lru-cache'\nimport type { CacheEntry, CacheHandler } from './types'\nimport {\n  areTagsExpired,\n  areTagsStale,\n  tagsManifest,\n  type TagManifestEntry,\n} from '../incremental-cache/tags-manifest.external'\n\ntype PrivateCacheEntry = {\n  entry: CacheEntry\n\n  // For the default cache we store errored cache\n  // entries and allow them to be used up to 3 times\n  // after that we want to dispose it and try for fresh\n\n  // If an entry is errored we return no entry\n  // three times so that we retry hitting origin (MISS)\n  // and then if it still fails to set after the third we\n  // return the errored content and use expiration of\n  // Math.min(30, entry.expiration)\n  isErrored: boolean\n  errorRetryCount: number\n\n  // compute size on set since we need to read size\n  // of the ReadableStream for LRU evicting\n  size: number\n}\n\nexport function createDefaultCacheHandler(maxSize: number): CacheHandler {\n  // If the max size is 0, return a cache handler that doesn't cache anything,\n  // this avoids an unnecessary LRUCache instance and potential memory\n  // allocation.\n  if (maxSize === 0) {\n    return {\n      get: () => Promise.resolve(undefined),\n      set: () => Promise.resolve(),\n      refreshTags: () => Promise.resolve(),\n      getExpiration: () => Promise.resolve(0),\n      updateTags: () => Promise.resolve(),\n    }\n  }\n\n  const memoryCache = new LRUCache<PrivateCacheEntry>(\n    maxSize,\n    (entry) => entry.size\n  )\n  const pendingSets = new Map<string, Promise<void>>()\n\n  const debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n    ? console.debug.bind(console, 'DefaultCacheHandler:')\n    : undefined\n\n  return {\n    async get(cacheKey) {\n      const pendingPromise = pendingSets.get(cacheKey)\n\n      if (pendingPromise) {\n        debug?.('get', cacheKey, 'pending')\n        await pendingPromise\n      }\n\n      const privateEntry = memoryCache.get(cacheKey)\n\n      if (!privateEntry) {\n        debug?.('get', cacheKey, 'not found')\n        return undefined\n      }\n\n      const entry = privateEntry.entry\n      if (\n        performance.timeOrigin + performance.now() >\n        entry.timestamp + entry.revalidate * 1000\n      ) {\n        // In-memory caches should expire after revalidate time because it is\n        // unlikely that a new entry will be able to be used before it is dropped\n        // from the cache.\n        debug?.('get', cacheKey, 'expired')\n\n        return undefined\n      }\n\n      let revalidate = entry.revalidate\n\n      if (areTagsExpired(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had expired tag')\n        return undefined\n      }\n\n      if (areTagsStale(entry.tags, entry.timestamp)) {\n        debug?.('get', cacheKey, 'had stale tag')\n        revalidate = -1\n      }\n\n      const [returnStream, newSaved] = entry.value.tee()\n      entry.value = newSaved\n\n      debug?.('get', cacheKey, 'found', {\n        tags: entry.tags,\n        timestamp: entry.timestamp,\n        expire: entry.expire,\n        revalidate,\n      })\n\n      return {\n        ...entry,\n        revalidate,\n        value: returnStream,\n      }\n    },\n\n    async set(cacheKey, pendingEntry) {\n      debug?.('set', cacheKey, 'start')\n\n      let resolvePending: () => void = () => {}\n      const pendingPromise = new Promise<void>((resolve) => {\n        resolvePending = resolve\n      })\n      pendingSets.set(cacheKey, pendingPromise)\n\n      const entry = await pendingEntry\n\n      let size = 0\n\n      try {\n        const [value, clonedValue] = entry.value.tee()\n        entry.value = value\n        const reader = clonedValue.getReader()\n\n        for (let chunk; !(chunk = await reader.read()).done; ) {\n          size += Buffer.from(chunk.value).byteLength\n        }\n\n        memoryCache.set(cacheKey, {\n          entry,\n          isErrored: false,\n          errorRetryCount: 0,\n          size,\n        })\n\n        debug?.('set', cacheKey, 'done')\n      } catch (err) {\n        // TODO: store partial buffer with error after we retry 3 times\n        debug?.('set', cacheKey, 'failed', err)\n      } finally {\n        resolvePending()\n        pendingSets.delete(cacheKey)\n      }\n    },\n\n    async refreshTags() {\n      // Nothing to do for an in-memory cache handler.\n    },\n\n    async getExpiration(tags) {\n      const expirations = tags.map((tag) => {\n        const entry = tagsManifest.get(tag)\n        if (!entry) return 0\n        // Return the most recent timestamp (either expired or stale)\n        return entry.expired || 0\n      })\n\n      const expiration = Math.max(...expirations, 0)\n\n      debug?.('getExpiration', { tags, expiration })\n\n      return expiration\n    },\n\n    async updateTags(tags, durations) {\n      const now = Math.round(performance.timeOrigin + performance.now())\n      debug?.('updateTags', { tags, timestamp: now })\n\n      for (const tag of tags) {\n        // TODO: update file-system-cache?\n        const existingEntry = tagsManifest.get(tag) || {}\n\n        if (durations) {\n          // Use provided durations directly\n          const updates: TagManifestEntry = { ...existingEntry }\n\n          // mark as stale immediately\n          updates.stale = now\n\n          if (durations.expire !== undefined) {\n            updates.expired = now + durations.expire * 1000 // Convert seconds to ms\n          }\n\n          tagsManifest.set(tag, updates)\n        } else {\n          // Update expired field for immediate expiration (default behavior when no durations provided)\n          tagsManifest.set(tag, { ...existingEntry, expired: now })\n        }\n      }\n    },\n  }\n}\n","import { createDefaultCacheHandler } from '../lib/cache-handlers/default'\nimport type { CacheHandler } from '../lib/cache-handlers/types'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? (message: string, ...args: any[]) => {\n      console.log(`use-cache: ${message}`, ...args)\n    }\n  : undefined\n\nconst handlersSymbol = Symbol.for('@next/cache-handlers')\nconst handlersMapSymbol = Symbol.for('@next/cache-handlers-map')\nconst handlersSetSymbol = Symbol.for('@next/cache-handlers-set')\n\n/**\n * The reference to the cache handlers. We store the cache handlers on the\n * global object so that we can access the same instance across different\n * boundaries (such as different copies of the same module).\n */\nconst reference: typeof globalThis & {\n  [handlersSymbol]?: {\n    RemoteCache?: CacheHandler\n    DefaultCache?: CacheHandler\n  }\n  [handlersMapSymbol]?: Map<string, CacheHandler>\n  [handlersSetSymbol]?: Set<CacheHandler>\n} = globalThis\n\n/**\n * Initialize the cache handlers.\n * @param cacheMaxMemorySize - The maximum memory size of the cache in bytes, if\n *  not provided, the default memory size will be used.\n * @returns `true` if the cache handlers were initialized, `false` if they were already initialized.\n */\nexport function initializeCacheHandlers(cacheMaxMemorySize: number): boolean {\n  // If the cache handlers have already been initialized, don't do it again.\n  if (reference[handlersMapSymbol]) {\n    debug?.('cache handlers already initialized')\n    return false\n  }\n\n  debug?.('initializing cache handlers')\n  reference[handlersMapSymbol] = new Map<string, CacheHandler>()\n\n  // Initialize the cache from the symbol contents first.\n  if (reference[handlersSymbol]) {\n    let fallback: CacheHandler\n    if (reference[handlersSymbol].DefaultCache) {\n      debug?.('setting \"default\" cache handler from symbol')\n      fallback = reference[handlersSymbol].DefaultCache\n    } else {\n      debug?.('setting \"default\" cache handler from default')\n      fallback = createDefaultCacheHandler(cacheMaxMemorySize)\n    }\n\n    reference[handlersMapSymbol].set('default', fallback)\n\n    if (reference[handlersSymbol].RemoteCache) {\n      debug?.('setting \"remote\" cache handler from symbol')\n      reference[handlersMapSymbol].set(\n        'remote',\n        reference[handlersSymbol].RemoteCache\n      )\n    } else {\n      debug?.('setting \"remote\" cache handler from default')\n      reference[handlersMapSymbol].set('remote', fallback)\n    }\n  } else {\n    const handler = createDefaultCacheHandler(cacheMaxMemorySize)\n\n    debug?.('setting \"default\" cache handler from default')\n    reference[handlersMapSymbol].set('default', handler)\n    debug?.('setting \"remote\" cache handler from default')\n    reference[handlersMapSymbol].set('remote', handler)\n  }\n\n  // Create a set of the cache handlers.\n  reference[handlersSetSymbol] = new Set(reference[handlersMapSymbol].values())\n\n  return true\n}\n\n/**\n * Get a cache handler by kind.\n * @param kind - The kind of cache handler to get.\n * @returns The cache handler, or `undefined` if it does not exist.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandler(kind: string): CacheHandler | undefined {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  return reference[handlersMapSymbol].get(kind)\n}\n\n/**\n * Get a set iterator over the cache handlers.\n * @returns An iterator over the cache handlers, or `undefined` if they are not\n * initialized.\n */\nexport function getCacheHandlers(): SetIterator<CacheHandler> | undefined {\n  if (!reference[handlersSetSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersSetSymbol].values()\n}\n\n/**\n * Get a map iterator over the cache handlers (keyed by kind).\n * @returns An iterator over the cache handler entries, or `undefined` if they\n * are not initialized.\n * @throws If the cache handlers are not initialized.\n */\nexport function getCacheHandlerEntries():\n  | MapIterator<[string, CacheHandler]>\n  | undefined {\n  if (!reference[handlersMapSymbol]) {\n    return undefined\n  }\n\n  return reference[handlersMapSymbol].entries()\n}\n\n/**\n * Set a cache handler by kind.\n * @param kind - The kind of cache handler to set.\n * @param cacheHandler - The cache handler to set.\n */\nexport function setCacheHandler(\n  kind: string,\n  cacheHandler: CacheHandler\n): void {\n  // This should never be called before initializeCacheHandlers.\n  if (!reference[handlersMapSymbol] || !reference[handlersSetSymbol]) {\n    throw new Error('Cache handlers not initialized')\n  }\n\n  debug?.('setting cache handler for \"%s\"', kind)\n  reference[handlersMapSymbol].set(kind, cacheHandler)\n  reference[handlersSetSymbol].add(cacheHandler)\n}\n","const USE_CACHE_TIMEOUT_ERROR_CODE = 'USE_CACHE_TIMEOUT'\n\nexport class UseCacheTimeoutError extends Error {\n  digest: typeof USE_CACHE_TIMEOUT_ERROR_CODE = USE_CACHE_TIMEOUT_ERROR_CODE\n\n  constructor() {\n    super(\n      'Filling a cache during prerender timed out, likely because request-specific arguments such as params, searchParams, cookies() or dynamic data were used inside \"use cache\".'\n    )\n  }\n}\n\nexport function isUseCacheTimeoutError(\n  err: unknown\n): err is UseCacheTimeoutError {\n  if (\n    typeof err !== 'object' ||\n    err === null ||\n    !('digest' in err) ||\n    typeof err.digest !== 'string'\n  ) {\n    return false\n  }\n\n  return err.digest === USE_CACHE_TIMEOUT_ERROR_CODE\n}\n","// This regex will have fast negatives meaning valid identifiers may not pass\n// this test. However this is only used during static generation to provide hints\n// about why a page bailed out of some or all prerendering and we can use bracket notation\n// for example while `_` is a valid identifier it's ok to print `searchParams['_']`\n// even if this would have been fine too `searchParams._`\nconst isDefinitelyAValidIdentifier = /^[A-Za-z_$][A-Za-z0-9_$]*$/\n\nexport function describeStringPropertyAccess(target: string, prop: string) {\n  if (isDefinitelyAValidIdentifier.test(prop)) {\n    return `\\`${target}.${prop}\\``\n  }\n  return `\\`${target}[${JSON.stringify(prop)}]\\``\n}\n\nexport function describeHasCheckingStringProperty(\n  target: string,\n  prop: string\n) {\n  const stringifiedProp = JSON.stringify(prop)\n  return `\\`Reflect.has(${target}, ${stringifiedProp})\\`, \\`${stringifiedProp} in ${target}\\`, or similar`\n}\n\nexport const wellKnownProperties = new Set([\n  'hasOwnProperty',\n  'isPrototypeOf',\n  'propertyIsEnumerable',\n  'toString',\n  'valueOf',\n  'toLocaleString',\n\n  // Promise prototype\n  'then',\n  'catch',\n  'finally',\n\n  // React Promise extension\n  'status',\n  // 'value',\n  // 'error',\n\n  // React introspection\n  'displayName',\n  '_debugInfo',\n\n  // Common tested properties\n  'toJSON',\n  '$$typeof',\n  '__esModule',\n])\n","import type { WorkStore } from '../app-render/work-async-storage.external'\n\nimport { ReflectAdapter } from '../web/spec-extension/adapters/reflect'\nimport {\n  throwToInterruptStaticGeneration,\n  postponeWithTracking,\n  annotateDynamicAccess,\n  delayUntilRuntimeStage,\n} from '../app-render/dynamic-rendering'\n\nimport {\n  workUnitAsyncStorage,\n  type PrerenderStoreLegacy,\n  type PrerenderStorePPR,\n  type PrerenderStoreModern,\n  type PrerenderStoreModernRuntime,\n  type StaticPrerenderStore,\n  throwInvariantForMissingStore,\n  type RequestStore,\n} from '../app-render/work-unit-async-storage.external'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\nimport { createDedupedByCallsiteServerErrorLoggerDev } from '../create-deduped-by-callsite-server-error-logger'\nimport {\n  describeStringPropertyAccess,\n  describeHasCheckingStringProperty,\n  wellKnownProperties,\n} from '../../shared/lib/utils/reflect-utils'\nimport {\n  throwWithStaticGenerationBailoutErrorWithDynamicError,\n  throwForSearchParamsAccessInUseCache,\n} from './utils'\nimport { RenderStage } from '../app-render/staged-rendering'\n\nexport type SearchParams = { [key: string]: string | string[] | undefined }\n\nexport function createSearchParamsFromClient(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createSearchParamsFromClient should not be called in cache contexts.'\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\n// generateMetadata always runs in RSC context so it is equivalent to a Server Page Component\nexport const createServerSearchParamsForMetadata =\n  createServerSearchParamsForServerPage\n\nexport function createServerSearchParamsForServerPage(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        return createStaticPrerenderSearchParams(workStore, workUnitStore)\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createServerSearchParamsForServerPage should not be called in cache contexts.'\n        )\n      case 'prerender-runtime':\n        return createRuntimePrerenderSearchParams(\n          underlyingSearchParams,\n          workUnitStore\n        )\n      case 'request':\n        return createRenderSearchParams(\n          underlyingSearchParams,\n          workStore,\n          workUnitStore\n        )\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nexport function createPrerenderSearchParamsForClientPage(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n      case 'prerender-client':\n        // We're prerendering in a mode that aborts (cacheComponents) and should stall\n        // the promise to ensure the RSC side is considered dynamic\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          '`searchParams`'\n        )\n      case 'prerender-runtime':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in a runtime prerender.'\n        )\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        throw new InvariantError(\n          'createPrerenderSearchParamsForClientPage should not be called in cache contexts.'\n        )\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n        return Promise.resolve({})\n      default:\n        workUnitStore satisfies never\n    }\n  }\n  throwInvariantForMissingStore()\n}\n\nfunction createStaticPrerenderSearchParams(\n  workStore: WorkStore,\n  prerenderStore: StaticPrerenderStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  }\n\n  switch (prerenderStore.type) {\n    case 'prerender':\n    case 'prerender-client':\n      // We are in a cacheComponents (PPR or otherwise) prerender\n      return makeHangingSearchParams(workStore, prerenderStore)\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n      // We are in a legacy static generation and need to interrupt the\n      // prerender when search params are accessed.\n      return makeErroringSearchParams(workStore, prerenderStore)\n    default:\n      return prerenderStore satisfies never\n  }\n}\n\nfunction createRuntimePrerenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workUnitStore: PrerenderStoreModernRuntime\n): Promise<SearchParams> {\n  return delayUntilRuntimeStage(\n    workUnitStore,\n    makeUntrackedSearchParams(underlyingSearchParams)\n  )\n}\n\nfunction createRenderSearchParams(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (workStore.forceStatic) {\n    // When using forceStatic we override all other logic and always just return an empty\n    // dictionary object.\n    return Promise.resolve({})\n  } else {\n    if (process.env.NODE_ENV === 'development') {\n      // Semantically we only need the dev tracking when running in `next dev`\n      // but since you would never use next dev with production NODE_ENV we use this\n      // as a proxy so we can statically exclude this code from production builds.\n      return makeUntrackedSearchParamsWithDevWarnings(\n        underlyingSearchParams,\n        workStore,\n        requestStore\n      )\n    } else {\n      return makeUntrackedSearchParams(underlyingSearchParams)\n    }\n  }\n}\n\ninterface CacheLifetime {}\nconst CachedSearchParams = new WeakMap<CacheLifetime, Promise<SearchParams>>()\n\nconst CachedSearchParamsForUseCache = new WeakMap<\n  CacheLifetime,\n  Promise<SearchParams>\n>()\n\nfunction makeHangingSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreModern\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(prerenderStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = makeHangingPromise<SearchParams>(\n    prerenderStore.renderSignal,\n    workStore.route,\n    '`searchParams`'\n  )\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      switch (prop) {\n        case 'then': {\n          const expression =\n            '`await searchParams`, `searchParams.then`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n        case 'status': {\n          const expression =\n            '`use(searchParams)`, `searchParams.status`, or similar'\n          annotateDynamicAccess(expression, prerenderStore)\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n\n        default: {\n          return ReflectAdapter.get(target, prop, receiver)\n        }\n      }\n    },\n  })\n\n  CachedSearchParams.set(prerenderStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeErroringSearchParams(\n  workStore: WorkStore,\n  prerenderStore: PrerenderStoreLegacy | PrerenderStorePPR\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const underlyingSearchParams = {}\n  // For search params we don't construct a ReactPromise because we want to interrupt\n  // rendering on any property access that was not set from outside and so we only want\n  // to have properties like value and status if React sets them.\n  const promise = Promise.resolve(underlyingSearchParams)\n\n  const proxiedPromise = new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it.\n        // We know it isn't a dynamic access because it can only be something\n        // that was previously written to the promise and thus not an underlying searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (typeof prop === 'string' && prop === 'then') {\n        const expression =\n          '`await searchParams`, `searchParams.then`, or similar'\n        if (workStore.dynamicShouldError) {\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        } else if (prerenderStore.type === 'prerender-ppr') {\n          // PPR Prerender (no cacheComponents)\n          postponeWithTracking(\n            workStore.route,\n            expression,\n            prerenderStore.dynamicTracking\n          )\n        } else {\n          // Legacy Prerender\n          throwToInterruptStaticGeneration(\n            expression,\n            workStore,\n            prerenderStore\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParams.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\n/**\n * This is a variation of `makeErroringSearchParams` that always throws an\n * error on access, because accessing searchParams inside of `\"use cache\"` is\n * not allowed.\n */\nexport function makeErroringSearchParamsForUseCache(\n  workStore: WorkStore\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParamsForUseCache.get(workStore)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve({})\n\n  const proxiedPromise = new Proxy(promise, {\n    get: function get(target, prop, receiver) {\n      if (Object.hasOwn(promise, prop)) {\n        // The promise has this property directly. we must return it. We know it\n        // isn't a dynamic access because it can only be something that was\n        // previously written to the promise and thus not an underlying\n        // searchParam value\n        return ReflectAdapter.get(target, prop, receiver)\n      }\n\n      if (\n        typeof prop === 'string' &&\n        (prop === 'then' || !wellKnownProperties.has(prop))\n      ) {\n        throwForSearchParamsAccessInUseCache(workStore, get)\n      }\n\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n  })\n\n  CachedSearchParamsForUseCache.set(workStore, proxiedPromise)\n  return proxiedPromise\n}\n\nfunction makeUntrackedSearchParams(\n  underlyingSearchParams: SearchParams\n): Promise<SearchParams> {\n  const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n  if (cachedSearchParams) {\n    return cachedSearchParams\n  }\n\n  const promise = Promise.resolve(underlyingSearchParams)\n  CachedSearchParams.set(underlyingSearchParams, promise)\n\n  return promise\n}\n\nfunction makeUntrackedSearchParamsWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  if (requestStore.asyncApiPromises) {\n    // Do not cache the resulting promise. If we do, we'll only show the first \"awaited at\"\n    // across all segments that receive searchParams.\n    return makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n  } else {\n    const cachedSearchParams = CachedSearchParams.get(underlyingSearchParams)\n    if (cachedSearchParams) {\n      return cachedSearchParams\n    }\n    const promise = makeUntrackedSearchParamsWithDevWarningsImpl(\n      underlyingSearchParams,\n      workStore,\n      requestStore\n    )\n    CachedSearchParams.set(requestStore, promise)\n    return promise\n  }\n}\n\nfunction makeUntrackedSearchParamsWithDevWarningsImpl(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  requestStore: RequestStore\n): Promise<SearchParams> {\n  const promiseInitialized = { current: false }\n  const proxiedUnderlying = instrumentSearchParamsObjectWithDevWarnings(\n    underlyingSearchParams,\n    workStore,\n    promiseInitialized\n  )\n\n  let promise: Promise<SearchParams>\n  if (requestStore.asyncApiPromises) {\n    // We wrap each instance of searchParams in a `new Promise()`.\n    // This is important when all awaits are in third party which would otherwise\n    // track all the way to the internal params.\n    const sharedSearchParamsParent =\n      requestStore.asyncApiPromises.sharedSearchParamsParent\n    promise = new Promise((resolve, reject) => {\n      sharedSearchParamsParent.then(() => resolve(proxiedUnderlying), reject)\n    })\n    // @ts-expect-error\n    promise.displayName = 'searchParams'\n  } else {\n    promise = makeDevtoolsIOAwarePromise(\n      proxiedUnderlying,\n      requestStore,\n      RenderStage.Runtime\n    )\n  }\n  promise.then(\n    () => {\n      promiseInitialized.current = true\n    },\n    // If we're in staged rendering, this promise will reject if the render\n    // is aborted before it can reach the runtime stage.\n    // In that case, we have to prevent an unhandled rejection from the promise\n    // created by this `.then()` call.\n    // This does not affect the `promiseInitialized` logic above,\n    // because `proxiedUnderlying` will not be used to resolve the promise,\n    // so there's no risk of any of its properties being accessed and triggering\n    // an undesireable warning.\n    ignoreReject\n  )\n\n  return instrumentSearchParamsPromiseWithDevWarnings(\n    underlyingSearchParams,\n    promise,\n    workStore\n  )\n}\n\nfunction ignoreReject() {}\n\nfunction instrumentSearchParamsObjectWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  workStore: WorkStore,\n  promiseInitialized: { current: boolean }\n) {\n  // We have an unfortunate sequence of events that requires this initialization logic. We want to instrument the underlying\n  // searchParams object to detect if you are accessing values in dev. This is used for warnings and for things like the static prerender\n  // indicator. However when we pass this proxy to our Promise.resolve() below the VM checks if the resolved value is a promise by looking\n  // at the `.then` property. To our dynamic tracking logic this is indistinguishable from a `then` searchParam and so we would normally trigger\n  // dynamic tracking. However we know that this .then is not real dynamic access, it's just how thenables resolve in sequence. So we introduce\n  // this initialization concept so we omit the dynamic check until after we've constructed our resolved promise.\n  return new Proxy(underlyingSearchParams, {\n    get(target, prop, receiver) {\n      if (typeof prop === 'string' && promiseInitialized.current) {\n        if (workStore.dynamicShouldError) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (workStore.dynamicShouldError) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          throwWithStaticGenerationBailoutErrorWithDynamicError(\n            workStore.route,\n            expression\n          )\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      if (workStore.dynamicShouldError) {\n        const expression =\n          '`{...searchParams}`, `Object.keys(searchParams)`, or similar'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nfunction instrumentSearchParamsPromiseWithDevWarnings(\n  underlyingSearchParams: SearchParams,\n  promise: Promise<SearchParams>,\n  workStore: WorkStore\n) {\n  // Track which properties we should warn for.\n  const proxiedProperties = new Set<string>()\n\n  Object.keys(underlyingSearchParams).forEach((prop) => {\n    if (wellKnownProperties.has(prop)) {\n      // These properties cannot be shadowed because they need to be the\n      // true underlying value for Promises to work correctly at runtime\n    } else {\n      proxiedProperties.add(prop)\n    }\n  })\n\n  return new Proxy(promise, {\n    get(target, prop, receiver) {\n      if (prop === 'then' && workStore.dynamicShouldError) {\n        const expression = '`searchParams.then`'\n        throwWithStaticGenerationBailoutErrorWithDynamicError(\n          workStore.route,\n          expression\n        )\n      }\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeStringPropertyAccess('searchParams', prop)\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return ReflectAdapter.get(target, prop, receiver)\n    },\n    set(target, prop, value, receiver) {\n      if (typeof prop === 'string') {\n        proxiedProperties.delete(prop)\n      }\n      return Reflect.set(target, prop, value, receiver)\n    },\n    has(target, prop) {\n      if (typeof prop === 'string') {\n        if (\n          !wellKnownProperties.has(prop) &&\n          (proxiedProperties.has(prop) ||\n            // We are accessing a property that doesn't exist on the promise nor\n            // the underlying searchParams.\n            Reflect.has(target, prop) === false)\n        ) {\n          const expression = describeHasCheckingStringProperty(\n            'searchParams',\n            prop\n          )\n          warnForSyncAccess(workStore.route, expression)\n        }\n      }\n      return Reflect.has(target, prop)\n    },\n    ownKeys(target) {\n      const expression = '`Object.keys(searchParams)` or similar'\n      warnForSyncAccess(workStore.route, expression)\n      return Reflect.ownKeys(target)\n    },\n  })\n}\n\nconst warnForSyncAccess = createDedupedByCallsiteServerErrorLoggerDev(\n  createSearchAccessError\n)\n\nfunction createSearchAccessError(\n  route: string | undefined,\n  expression: string\n) {\n  const prefix = route ? `Route \"${route}\" ` : 'This route '\n  return new Error(\n    `${prefix}used ${expression}. ` +\n      `\\`searchParams\\` is a Promise and must be unwrapped with \\`await\\` or \\`React.use()\\` before accessing its properties. ` +\n      `Learn more: https://nextjs.org/docs/messages/sync-dynamic-apis`\n  )\n}\n","export type LazyResult<TValue> = PromiseLike<TValue> & { value?: TValue }\nexport type ResolvedLazyResult<TValue> = PromiseLike<TValue> & { value: TValue }\n\n/**\n * Calls the given function only when the returned promise-like object is\n * awaited. Afterwards, it provides the resolved value synchronously as `value`\n * property.\n */\nexport function createLazyResult<TValue>(\n  fn: () => Promise<TValue> | TValue\n): LazyResult<TValue> {\n  let pendingResult: Promise<TValue> | undefined\n\n  const result: LazyResult<TValue> = {\n    then(onfulfilled, onrejected) {\n      if (!pendingResult) {\n        pendingResult = Promise.resolve(fn())\n      }\n\n      pendingResult\n        .then((value) => {\n          result.value = value\n        })\n        .catch(() => {\n          // The externally awaited result will be rejected via `onrejected`. We\n          // don't need to handle it here. But we do want to avoid an unhandled\n          // rejection.\n        })\n\n      return pendingResult.then(onfulfilled, onrejected)\n    },\n  }\n\n  return result\n}\n\nexport function isResolvedLazyResult<TValue>(\n  result: LazyResult<TValue>\n): result is ResolvedLazyResult<TValue> {\n  return result.hasOwnProperty('value')\n}\n","// ISC License\n\n// Copyright (c) 2021 Alexey Raspopov, Kostiantyn Denysov, Anton Verinov\n\n// Permission to use, copy, modify, and/or distribute this software for any\n// purpose with or without fee is hereby granted, provided that the above\n// copyright notice and this permission notice appear in all copies.\n\n// THE SOFTWARE IS PROVIDED \"AS IS\" AND THE AUTHOR DISCLAIMS ALL WARRANTIES\n// WITH REGARD TO THIS SOFTWARE INCLUDING ALL IMPLIED WARRANTIES OF\n// MERCHANTABILITY AND FITNESS. IN NO EVENT SHALL THE AUTHOR BE LIABLE FOR\n// ANY SPECIAL, DIRECT, INDIRECT, OR CONSEQUENTIAL DAMAGES OR ANY DAMAGES\n// WHATSOEVER RESULTING FROM LOSS OF USE, DATA OR PROFITS, WHETHER IN AN\n// ACTION OF CONTRACT, NEGLIGENCE OR OTHER TORTIOUS ACTION, ARISING OUT OF\n// OR IN CONNECTION WITH THE USE OR PERFORMANCE OF THIS SOFTWARE.\n//\n// https://github.com/alexeyraspopov/picocolors/blob/b6261487e7b81aaab2440e397a356732cad9e342/picocolors.js#L1\n\nconst { env, stdout } = globalThis?.process ?? {}\n\nconst enabled =\n  env &&\n  !env.NO_COLOR &&\n  (env.FORCE_COLOR || (stdout?.isTTY && !env.CI && env.TERM !== 'dumb'))\n\nconst replaceClose = (\n  str: string,\n  close: string,\n  replace: string,\n  index: number\n): string => {\n  const start = str.substring(0, index) + replace\n  const end = str.substring(index + close.length)\n  const nextIndex = end.indexOf(close)\n  return ~nextIndex\n    ? start + replaceClose(end, close, replace, nextIndex)\n    : start + end\n}\n\nconst formatter = (open: string, close: string, replace = open) => {\n  if (!enabled) return String\n  return (input: string) => {\n    const string = '' + input\n    const index = string.indexOf(close, open.length)\n    return ~index\n      ? open + replaceClose(string, close, replace, index) + close\n      : open + string + close\n  }\n}\n\nexport const reset = enabled ? (s: string) => `\\x1b[0m${s}\\x1b[0m` : String\nexport const bold = formatter('\\x1b[1m', '\\x1b[22m', '\\x1b[22m\\x1b[1m')\nexport const dim = formatter('\\x1b[2m', '\\x1b[22m', '\\x1b[22m\\x1b[2m')\nexport const italic = formatter('\\x1b[3m', '\\x1b[23m')\nexport const underline = formatter('\\x1b[4m', '\\x1b[24m')\nexport const inverse = formatter('\\x1b[7m', '\\x1b[27m')\nexport const hidden = formatter('\\x1b[8m', '\\x1b[28m')\nexport const strikethrough = formatter('\\x1b[9m', '\\x1b[29m')\nexport const black = formatter('\\x1b[30m', '\\x1b[39m')\nexport const red = formatter('\\x1b[31m', '\\x1b[39m')\nexport const green = formatter('\\x1b[32m', '\\x1b[39m')\nexport const yellow = formatter('\\x1b[33m', '\\x1b[39m')\nexport const blue = formatter('\\x1b[34m', '\\x1b[39m')\nexport const magenta = formatter('\\x1b[35m', '\\x1b[39m')\nexport const purple = formatter('\\x1b[38;2;173;127;168m', '\\x1b[39m')\nexport const cyan = formatter('\\x1b[36m', '\\x1b[39m')\nexport const white = formatter('\\x1b[37m', '\\x1b[39m')\nexport const gray = formatter('\\x1b[90m', '\\x1b[39m')\nexport const bgBlack = formatter('\\x1b[40m', '\\x1b[49m')\nexport const bgRed = formatter('\\x1b[41m', '\\x1b[49m')\nexport const bgGreen = formatter('\\x1b[42m', '\\x1b[49m')\nexport const bgYellow = formatter('\\x1b[43m', '\\x1b[49m')\nexport const bgBlue = formatter('\\x1b[44m', '\\x1b[49m')\nexport const bgMagenta = formatter('\\x1b[45m', '\\x1b[49m')\nexport const bgCyan = formatter('\\x1b[46m', '\\x1b[49m')\nexport const bgWhite = formatter('\\x1b[47m', '\\x1b[49m')\n","import { bold, green, magenta, red, yellow, white } from '../../lib/picocolors'\nimport { LRUCache } from '../../server/lib/lru-cache'\n\nexport const prefixes = {\n  wait: white(bold('')),\n  error: red(bold('')),\n  warn: yellow(bold('')),\n  ready: '', // no color\n  info: white(bold(' ')),\n  event: green(bold('')),\n  trace: magenta(bold('')),\n} as const\n\nconst LOGGING_METHOD = {\n  log: 'log',\n  warn: 'warn',\n  error: 'error',\n} as const\n\nfunction prefixedLog(prefixType: keyof typeof prefixes, ...message: any[]) {\n  if ((message[0] === '' || message[0] === undefined) && message.length === 1) {\n    message.shift()\n  }\n\n  const consoleMethod: keyof typeof LOGGING_METHOD =\n    prefixType in LOGGING_METHOD\n      ? LOGGING_METHOD[prefixType as keyof typeof LOGGING_METHOD]\n      : 'log'\n\n  const prefix = prefixes[prefixType]\n  // If there's no message, don't print the prefix but a new line\n  if (message.length === 0) {\n    console[consoleMethod]('')\n  } else {\n    // Ensure if there's ANSI escape codes it's concatenated into one string.\n    // Chrome DevTool can only handle color if it's in one string.\n    if (message.length === 1 && typeof message[0] === 'string') {\n      console[consoleMethod](prefix + ' ' + message[0])\n    } else {\n      console[consoleMethod](prefix, ...message)\n    }\n  }\n}\n\nexport function bootstrap(message: string) {\n  console.log(message)\n}\n\nexport function wait(...message: any[]) {\n  prefixedLog('wait', ...message)\n}\n\nexport function error(...message: any[]) {\n  prefixedLog('error', ...message)\n}\n\nexport function warn(...message: any[]) {\n  prefixedLog('warn', ...message)\n}\n\nexport function ready(...message: any[]) {\n  prefixedLog('ready', ...message)\n}\n\nexport function info(...message: any[]) {\n  prefixedLog('info', ...message)\n}\n\nexport function event(...message: any[]) {\n  prefixedLog('event', ...message)\n}\n\nexport function trace(...message: any[]) {\n  prefixedLog('trace', ...message)\n}\n\nconst warnOnceCache = new LRUCache<string>(10_000, (value) => value.length)\nexport function warnOnce(...message: any[]) {\n  const key = message.join(' ')\n  if (!warnOnceCache.has(key)) {\n    warnOnceCache.set(key, key)\n    warn(...message)\n  }\n}\n\nconst errorOnceCache = new LRUCache<string>(10_000, (value) => value.length)\nexport function errorOnce(...message: any[]) {\n  const key = message.join(' ')\n  if (!errorOnceCache.has(key)) {\n    errorOnceCache.set(key, key)\n    error(...message)\n  }\n}\n","import type { DeepReadonly } from '../../shared/lib/deep-readonly'\n/* eslint-disable import/no-extraneous-dependencies */\nimport {\n  renderToReadableStream,\n  decodeReply,\n  decodeReplyFromAsyncIterable,\n  createTemporaryReferenceSet as createServerTemporaryReferenceSet,\n} from 'react-server-dom-webpack/server'\nimport {\n  createFromReadableStream,\n  encodeReply,\n  createTemporaryReferenceSet as createClientTemporaryReferenceSet,\n} from 'react-server-dom-webpack/client'\nimport { prerender } from 'react-server-dom-webpack/static'\n/* eslint-enable import/no-extraneous-dependencies */\n\nimport type { WorkStore } from '../app-render/work-async-storage.external'\nimport { workAsyncStorage } from '../app-render/work-async-storage.external'\nimport type {\n  PrerenderStoreModernClient,\n  PrerenderStoreModernRuntime,\n  PrivateUseCacheStore,\n  RequestStore,\n  RevalidateStore,\n  UseCacheStore,\n  WorkUnitStore,\n} from '../app-render/work-unit-async-storage.external'\nimport {\n  getHmrRefreshHash,\n  getRenderResumeDataCache,\n  getPrerenderResumeDataCache,\n  workUnitAsyncStorage,\n  getDraftModeProviderForCacheScope,\n  getCacheSignal,\n  isHmrRefresh,\n  getServerComponentsHmrCache,\n  getRuntimeStagePromise,\n} from '../app-render/work-unit-async-storage.external'\n\nimport {\n  makeDevtoolsIOAwarePromise,\n  makeHangingPromise,\n} from '../dynamic-rendering-utils'\n\nimport type { ClientReferenceManifest } from '../../build/webpack/plugins/flight-manifest-plugin'\n\nimport {\n  getClientReferenceManifest,\n  getServerModuleMap,\n} from '../app-render/manifests-singleton'\nimport type { CacheEntry } from '../lib/cache-handlers/types'\nimport type { CacheSignal } from '../app-render/cache-signal'\nimport { decryptActionBoundArgs } from '../app-render/encryption'\nimport { InvariantError } from '../../shared/lib/invariant-error'\nimport { createReactServerErrorHandler } from '../app-render/create-error-handler'\nimport { DYNAMIC_EXPIRE, RUNTIME_PREFETCH_DYNAMIC_STALE } from './constants'\nimport { getCacheHandler } from './handlers'\nimport { UseCacheTimeoutError } from './use-cache-errors'\nimport {\n  createHangingInputAbortSignal,\n  postponeWithTracking,\n  throwToInterruptStaticGeneration,\n} from '../app-render/dynamic-rendering'\nimport {\n  makeErroringSearchParamsForUseCache,\n  type SearchParams,\n} from '../request/search-params'\nimport type { Params } from '../request/params'\nimport { createLazyResult, isResolvedLazyResult } from '../lib/lazy-result'\nimport { dynamicAccessAsyncStorage } from '../app-render/dynamic-access-async-storage.external'\nimport type { CacheLife } from './cache-life'\nimport { RenderStage } from '../app-render/staged-rendering'\nimport * as Log from '../../build/output/log'\n\ninterface PrivateCacheContext {\n  readonly kind: 'private'\n  readonly outerWorkUnitStore:\n    | RequestStore\n    | PrivateUseCacheStore\n    | PrerenderStoreModernRuntime\n}\n\ninterface PublicCacheContext {\n  readonly kind: 'public'\n  // TODO: We should probably forbid nesting \"use cache\" inside unstable_cache.\n  readonly outerWorkUnitStore:\n    | Exclude<WorkUnitStore, PrerenderStoreModernClient>\n    | undefined\n}\n\ntype CacheContext = PrivateCacheContext | PublicCacheContext\n\ntype CacheKeyParts =\n  | [buildId: string, id: string, args: unknown[]]\n  | [buildId: string, id: string, args: unknown[], hmrRefreshHash: string]\n\ninterface UseCachePageInnerProps {\n  params: Promise<Params>\n  searchParams?: Promise<SearchParams>\n}\n\nexport interface UseCachePageProps {\n  params: Promise<Params>\n  searchParams: Promise<SearchParams>\n  $$isPage: true\n}\n\nexport type UseCacheLayoutProps = {\n  params: Promise<Params>\n  $$isLayout: true\n} & {\n  // The value type should be React.ReactNode. But such an index signature would\n  // be incompatible with the other two props.\n  [slot: string]: any\n}\n\nconst isEdgeRuntime = process.env.NEXT_RUNTIME === 'edge'\n\nconst debug = process.env.NEXT_PRIVATE_DEBUG_CACHE\n  ? console.debug.bind(console, 'use-cache:')\n  : undefined\n\nconst filterStackFrame =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .filterStackFrameDEV\n    : undefined\nconst findSourceMapURL =\n  process.env.NODE_ENV !== 'production'\n    ? (require('../lib/source-maps') as typeof import('../lib/source-maps'))\n        .findSourceMapURLDEV\n    : undefined\n\nfunction generateCacheEntry(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n  // generation cannot read anything from the context we're currently executing which\n  // might include request specific things like cookies() inside a React.cache().\n  // Note: It is important that we await at least once before this because it lets us\n  // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n  return workStore.runInCleanSnapshot(\n    generateCacheEntryWithRestoredWorkStore,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction generateCacheEntryWithRestoredWorkStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  // Since we cleared the AsyncLocalStorage we need to restore the workStore.\n  // Note: We explicitly don't restore the RequestStore nor the PrerenderStore.\n  // We don't want any request specific information leaking an we don't want to create a\n  // bloated fake request mock for every cache call. So any feature that currently lives\n  // in RequestStore but should be available to Caches need to move to WorkStore.\n  // PrerenderStore is not needed inside the cache scope because the outer most one will\n  // be the one to report its result to the outer Prerender.\n  return workAsyncStorage.run(\n    workStore,\n    generateCacheEntryWithCacheContext,\n    workStore,\n    cacheContext,\n    clientReferenceManifest,\n    encodedArguments,\n    fn,\n    timeoutError\n  )\n}\n\nfunction createUseCacheStore(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  defaultCacheLife: Required<CacheLife>\n): UseCacheStore {\n  if (cacheContext.kind === 'private') {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    return {\n      type: 'private-cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash: getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: isHmrRefresh(workStore, outerWorkUnitStore),\n      serverComponentsHmrCache: getServerComponentsHmrCache(\n        workStore,\n        outerWorkUnitStore\n      ),\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      runtimeStagePromise: getRuntimeStagePromise(outerWorkUnitStore),\n      draftMode: getDraftModeProviderForCacheScope(\n        workStore,\n        outerWorkUnitStore\n      ),\n      rootParams: outerWorkUnitStore.rootParams,\n      headers: outerWorkUnitStore.headers,\n      cookies: outerWorkUnitStore.cookies,\n    }\n  } else {\n    let useCacheOrRequestStore: RequestStore | UseCacheStore | undefined\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    if (outerWorkUnitStore) {\n      switch (outerWorkUnitStore?.type) {\n        case 'cache':\n        case 'private-cache':\n        case 'request':\n          useCacheOrRequestStore = outerWorkUnitStore\n          break\n        case 'prerender-runtime':\n        case 'prerender':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'unstable-cache':\n          break\n        default:\n          outerWorkUnitStore satisfies never\n      }\n    }\n\n    return {\n      type: 'cache',\n      phase: 'render',\n      implicitTags: outerWorkUnitStore?.implicitTags,\n      revalidate: defaultCacheLife.revalidate,\n      expire: defaultCacheLife.expire,\n      stale: defaultCacheLife.stale,\n      explicitRevalidate: undefined,\n      explicitExpire: undefined,\n      explicitStale: undefined,\n      tags: null,\n      hmrRefreshHash:\n        outerWorkUnitStore && getHmrRefreshHash(workStore, outerWorkUnitStore),\n      isHmrRefresh: useCacheOrRequestStore?.isHmrRefresh ?? false,\n      serverComponentsHmrCache:\n        useCacheOrRequestStore?.serverComponentsHmrCache,\n      forceRevalidate: shouldForceRevalidate(workStore, outerWorkUnitStore),\n      draftMode:\n        outerWorkUnitStore &&\n        getDraftModeProviderForCacheScope(workStore, outerWorkUnitStore),\n    }\n  }\n}\n\nfunction assertDefaultCacheLife(\n  defaultCacheLife: CacheLife | undefined\n): asserts defaultCacheLife is Required<CacheLife> {\n  if (\n    !defaultCacheLife ||\n    defaultCacheLife.revalidate == null ||\n    defaultCacheLife.expire == null ||\n    defaultCacheLife.stale == null\n  ) {\n    throw new InvariantError(\n      'A default cacheLife profile must always be provided.'\n    )\n  }\n}\n\nfunction generateCacheEntryWithCacheContext(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n) {\n  if (!workStore.cacheLifeProfiles) {\n    throw new InvariantError('cacheLifeProfiles should always be provided.')\n  }\n  const defaultCacheLife = workStore.cacheLifeProfiles['default']\n  assertDefaultCacheLife(defaultCacheLife)\n\n  // Initialize the Store for this Cache entry.\n  const cacheStore = createUseCacheStore(\n    workStore,\n    cacheContext,\n    defaultCacheLife\n  )\n\n  return workUnitAsyncStorage.run(cacheStore, () =>\n    dynamicAccessAsyncStorage.run(\n      { abortController: new AbortController() },\n      generateCacheEntryImpl,\n      workStore,\n      cacheContext,\n      cacheStore,\n      clientReferenceManifest,\n      encodedArguments,\n      fn,\n      timeoutError\n    )\n  )\n}\n\nfunction propagateCacheLifeAndTagsToRevalidateStore(\n  revalidateStore: RevalidateStore,\n  entry: CacheEntry\n): void {\n  const outerTags = (revalidateStore.tags ??= [])\n\n  for (const tag of entry.tags) {\n    if (!outerTags.includes(tag)) {\n      outerTags.push(tag)\n    }\n  }\n\n  if (revalidateStore.stale > entry.stale) {\n    revalidateStore.stale = entry.stale\n  }\n\n  if (revalidateStore.revalidate > entry.revalidate) {\n    revalidateStore.revalidate = entry.revalidate\n  }\n\n  if (revalidateStore.expire > entry.expire) {\n    revalidateStore.expire = entry.expire\n  }\n}\n\nfunction propagateCacheLifeAndTags(\n  cacheContext: CacheContext,\n  entry: CacheEntry\n): void {\n  if (cacheContext.kind === 'private') {\n    switch (cacheContext.outerWorkUnitStore.type) {\n      case 'prerender-runtime':\n      case 'private-cache':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  } else {\n    switch (cacheContext.outerWorkUnitStore?.type) {\n      case 'cache':\n      case 'private-cache':\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n        propagateCacheLifeAndTagsToRevalidateStore(\n          cacheContext.outerWorkUnitStore,\n          entry\n        )\n        break\n      case 'request':\n      case 'unstable-cache':\n      case undefined:\n        break\n      default:\n        cacheContext.outerWorkUnitStore satisfies never\n    }\n  }\n}\n\nasync function collectResult(\n  savedStream: ReadableStream<Uint8Array>,\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  startTime: number,\n  errors: Array<unknown> // This is a live array that gets pushed into.\n): Promise<CacheEntry> {\n  // We create a buffered stream that collects all chunks until the end to\n  // ensure that RSC has finished rendering and therefore we have collected\n  // all tags. In the future the RSC API might allow for the equivalent of\n  // the allReady Promise that exists on SSR streams.\n  //\n  // If something errored or rejected anywhere in the render, we close\n  // the stream as errored. This lets a CacheHandler choose to save the\n  // partial result up until that point for future hits for a while to avoid\n  // unnecessary retries or not to retry. We use the end of the stream for\n  // this to avoid another complicated side-channel. A receiver has to consider\n  // that the stream might also error for other reasons anyway such as losing\n  // connection.\n\n  const buffer: Uint8Array[] = []\n  const reader = savedStream.getReader()\n\n  try {\n    for (let entry; !(entry = await reader.read()).done; ) {\n      buffer.push(entry.value)\n    }\n  } catch (error) {\n    errors.push(error)\n  }\n\n  let idx = 0\n  const bufferStream = new ReadableStream<Uint8Array>({\n    pull(controller) {\n      if (workStore.invalidDynamicUsageError) {\n        controller.error(workStore.invalidDynamicUsageError)\n      } else if (idx < buffer.length) {\n        controller.enqueue(buffer[idx++])\n      } else if (errors.length > 0) {\n        // TODO: Should we use AggregateError here?\n        controller.error(errors[0])\n      } else {\n        controller.close()\n      }\n    },\n  })\n\n  const collectedTags = innerCacheStore.tags\n  // If cacheLife() was used to set an explicit revalidate time we use that.\n  // Otherwise, we use the lowest of all inner fetch()/unstable_cache() or nested \"use cache\".\n  // If they're lower than our default.\n  const collectedRevalidate =\n    innerCacheStore.explicitRevalidate !== undefined\n      ? innerCacheStore.explicitRevalidate\n      : innerCacheStore.revalidate\n  const collectedExpire =\n    innerCacheStore.explicitExpire !== undefined\n      ? innerCacheStore.explicitExpire\n      : innerCacheStore.expire\n  const collectedStale =\n    innerCacheStore.explicitStale !== undefined\n      ? innerCacheStore.explicitStale\n      : innerCacheStore.stale\n\n  const entry: CacheEntry = {\n    value: bufferStream,\n    timestamp: startTime,\n    revalidate: collectedRevalidate,\n    expire: collectedExpire,\n    stale: collectedStale,\n    tags: collectedTags === null ? [] : collectedTags,\n  }\n\n  if (cacheContext.outerWorkUnitStore) {\n    const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n    // Propagate cache life & tags to the parent context if appropriate.\n    switch (outerWorkUnitStore.type) {\n      case 'prerender':\n      case 'prerender-runtime': {\n        // If we've just created a cache result, and we're filling caches for a\n        // Cache Components prerender, then we don't want to propagate cache\n        // life & tags yet, in case the entry ends up being omitted from the\n        // final prerender due to short expire/stale times. If it is omitted,\n        // then it shouldn't have any effects on the prerender. We'll decide\n        // whether or not this cache should have its life & tags propagated when\n        // we read the entry in the final prerender from the resume data cache.\n\n        break\n      }\n      case 'request': {\n        if (\n          process.env.NODE_ENV === 'development' &&\n          outerWorkUnitStore.cacheSignal\n        ) {\n          // If we're filling caches for a dev request, apply the same logic as prerenders do above,\n          // and don't propagate cache life/tags yet.\n          break\n        }\n        // fallthrough\n      }\n\n      case 'private-cache':\n      case 'cache':\n      case 'unstable-cache':\n      case 'prerender-legacy':\n      case 'prerender-ppr': {\n        propagateCacheLifeAndTags(cacheContext, entry)\n        break\n      }\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n\n    const cacheSignal = getCacheSignal(outerWorkUnitStore)\n    if (cacheSignal) {\n      cacheSignal.endRead()\n    }\n  }\n\n  return entry\n}\n\ntype GenerateCacheEntryResult =\n  | {\n      readonly type: 'cached'\n      readonly stream: ReadableStream\n      readonly pendingCacheEntry: Promise<CacheEntry>\n    }\n  | {\n      readonly type: 'prerender-dynamic'\n      readonly hangingPromise: Promise<never>\n    }\n\nasync function generateCacheEntryImpl(\n  workStore: WorkStore,\n  cacheContext: CacheContext,\n  innerCacheStore: UseCacheStore,\n  clientReferenceManifest: DeepReadonly<ClientReferenceManifest>,\n  encodedArguments: FormData | string,\n  fn: (...args: unknown[]) => Promise<unknown>,\n  timeoutError: UseCacheTimeoutError\n): Promise<GenerateCacheEntryResult> {\n  const temporaryReferences = createServerTemporaryReferenceSet()\n  const outerWorkUnitStore = cacheContext.outerWorkUnitStore\n\n  const [, , args] =\n    typeof encodedArguments === 'string'\n      ? await decodeReply<CacheKeyParts>(\n          encodedArguments,\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n      : await decodeReplyFromAsyncIterable<CacheKeyParts>(\n          {\n            async *[Symbol.asyncIterator]() {\n              for (const entry of encodedArguments) {\n                yield entry\n              }\n\n              if (outerWorkUnitStore) {\n                switch (outerWorkUnitStore.type) {\n                  case 'prerender-runtime':\n                  case 'prerender':\n                    // The encoded arguments might contain hanging promises. In\n                    // this case we don't want to reject with \"Error: Connection\n                    // closed.\", so we intentionally keep the iterable alive.\n                    // This is similar to the halting trick that we do while\n                    // rendering.\n                    await new Promise<void>((resolve) => {\n                      if (outerWorkUnitStore.renderSignal.aborted) {\n                        resolve()\n                      } else {\n                        outerWorkUnitStore.renderSignal.addEventListener(\n                          'abort',\n                          () => resolve(),\n                          { once: true }\n                        )\n                      }\n                    })\n                    break\n                  case 'prerender-ppr':\n                  case 'prerender-legacy':\n                  case 'request':\n                  case 'cache':\n                  case 'private-cache':\n                  case 'unstable-cache':\n                    break\n                  default:\n                    outerWorkUnitStore satisfies never\n                }\n              }\n            },\n          },\n          getServerModuleMap(),\n          { temporaryReferences }\n        )\n\n  // Track the timestamp when we started computing the result.\n  const startTime = performance.timeOrigin + performance.now()\n\n  // Invoke the inner function to load a new result. We delay the invocation\n  // though, until React awaits the promise so that React's request store (ALS)\n  // is available when the function is invoked. This allows us, for example, to\n  // capture logs so that we can later replay them.\n  const resultPromise = createLazyResult(fn.bind(null, ...args))\n\n  let errors: Array<unknown> = []\n\n  // In the \"Cache\" environment, we only need to make sure that the error\n  // digests are handled correctly. Error formatting and reporting is not\n  // necessary here; the errors are encoded in the stream, and will be reported\n  // in the \"Server\" environment.\n  const handleError = createReactServerErrorHandler(\n    workStore.dev,\n    workStore.isBuildTimePrerendering ?? false,\n    workStore.reactServerErrorsByDigest,\n    (error) => {\n      // In production, we log the original error here. It gets a digest that\n      // can be used to associate the error with the obfuscated error that might\n      // be logged if the error is caught. In development, we prefer logging the\n      // transported error in the server environment. It's not obfuscated and\n      // also includes the (dev-only) environment name.\n      if (process.env.NODE_ENV === 'production') {\n        Log.error(error)\n      }\n\n      errors.push(error)\n    }\n  )\n\n  let stream: ReadableStream<Uint8Array>\n\n  switch (outerWorkUnitStore?.type) {\n    case 'prerender-runtime':\n    case 'prerender':\n      const timeoutAbortController = new AbortController()\n\n      // If we're prerendering, we give you 50 seconds to fill a cache entry.\n      // Otherwise we assume you stalled on hanging input and de-opt. This needs\n      // to be lower than just the general timeout of 60 seconds.\n      const timer = setTimeout(() => {\n        workStore.invalidDynamicUsageError = timeoutError\n        timeoutAbortController.abort(timeoutError)\n      }, 50000)\n\n      const dynamicAccessAbortSignal =\n        dynamicAccessAsyncStorage.getStore()?.abortController.signal\n\n      const abortSignal = dynamicAccessAbortSignal\n        ? AbortSignal.any([\n            dynamicAccessAbortSignal,\n            outerWorkUnitStore.renderSignal,\n            timeoutAbortController.signal,\n          ])\n        : timeoutAbortController.signal\n\n      const { prelude } = await prerender(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          signal: abortSignal,\n          temporaryReferences,\n          onError(error) {\n            if (abortSignal.aborted && abortSignal.reason === error) {\n              return undefined\n            }\n\n            return handleError(error)\n          },\n        }\n      )\n\n      clearTimeout(timer)\n\n      if (timeoutAbortController.signal.aborted) {\n        // When the timeout is reached we always error the stream. Even for\n        // fallback shell prerenders we don't want to return a hanging promise,\n        // which would allow the function to become a dynamic hole. Because that\n        // would mean that a non-empty shell could be generated which would be\n        // subject to revalidation, and we don't want to create long\n        // revalidation times.\n        stream = new ReadableStream({\n          start(controller) {\n            controller.error(timeoutAbortController.signal.reason)\n          },\n        })\n      } else if (dynamicAccessAbortSignal?.aborted) {\n        // If the prerender is aborted because of dynamic access (e.g. reading\n        // fallback params), we return a hanging promise. This essentially makes\n        // the \"use cache\" function dynamic.\n        const hangingPromise = makeHangingPromise<never>(\n          outerWorkUnitStore.renderSignal,\n          workStore.route,\n          'dynamic \"use cache\"'\n        )\n\n        if (outerWorkUnitStore.cacheSignal) {\n          outerWorkUnitStore.cacheSignal.endRead()\n        }\n\n        return { type: 'prerender-dynamic', hangingPromise }\n      } else {\n        stream = prelude\n      }\n      break\n    case 'request':\n      // If we're filling caches for a staged render, make sure that\n      // it takes at least a task, so we'll always notice a cache miss between stages.\n      //\n      // TODO(restart-on-cache-miss): This is suboptimal.\n      // Ideally we wouldn't need to restart for microtasky caches,\n      // but the current logic for omitting short-lived caches only works correctly\n      // if we do a second render, so that's the best we can do until we refactor that.\n      if (\n        process.env.NODE_ENV === 'development' &&\n        outerWorkUnitStore.cacheSignal\n      ) {\n        await new Promise((resolve) => setTimeout(resolve))\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      stream = renderToReadableStream(\n        resultPromise,\n        clientReferenceManifest.clientModules,\n        {\n          environmentName: 'Cache',\n          filterStackFrame,\n          temporaryReferences,\n          onError: handleError,\n        }\n      )\n      break\n    default:\n      return outerWorkUnitStore satisfies never\n  }\n\n  const [returnStream, savedStream] = stream.tee()\n\n  const pendingCacheEntry = collectResult(\n    savedStream,\n    workStore,\n    cacheContext,\n    innerCacheStore,\n    startTime,\n    errors\n  )\n\n  if (process.env.NODE_ENV === 'development') {\n    // Name the stream for React DevTools.\n    // @ts-expect-error\n    returnStream.name = 'use cache'\n  }\n\n  return {\n    type: 'cached',\n    // Return the stream as we're creating it. This means that if it ends up\n    // erroring we cannot return a stale-if-error version but it allows\n    // streaming back the result earlier.\n    stream: returnStream,\n    pendingCacheEntry,\n  }\n}\n\nfunction cloneCacheEntry(entry: CacheEntry): [CacheEntry, CacheEntry] {\n  const [streamA, streamB] = entry.value.tee()\n  entry.value = streamA\n  const clonedEntry: CacheEntry = {\n    value: streamB,\n    timestamp: entry.timestamp,\n    revalidate: entry.revalidate,\n    expire: entry.expire,\n    stale: entry.stale,\n    tags: entry.tags,\n  }\n  return [entry, clonedEntry]\n}\n\nasync function clonePendingCacheEntry(\n  pendingCacheEntry: Promise<CacheEntry>\n): Promise<[CacheEntry, CacheEntry]> {\n  const entry = await pendingCacheEntry\n  return cloneCacheEntry(entry)\n}\n\nasync function getNthCacheEntry(\n  split: Promise<[CacheEntry, CacheEntry]>,\n  i: number\n): Promise<CacheEntry> {\n  return (await split)[i]\n}\n\nasync function encodeFormData(formData: FormData): Promise<string> {\n  let result = ''\n  for (let [key, value] of formData) {\n    // We don't need this key to be serializable but from a security perspective it should not be\n    // possible to generate a string that looks the same from a different structure. To ensure this\n    // we need a delimeter between fields but just using a delimeter is not enough since a string\n    // might contain that delimeter. We use the length of each field as the delimeter to avoid\n    // escaping the values.\n    result += key.length.toString(16) + ':' + key\n    let stringValue\n    if (typeof value === 'string') {\n      stringValue = value\n    } else {\n      // The FormData might contain binary data that is not valid UTF-8 so this cache\n      // key may generate a UCS-2 string. Passing this to another service needs to be\n      // aware that the key might not be compatible.\n      const arrayBuffer = await value.arrayBuffer()\n      if (arrayBuffer.byteLength % 2 === 0) {\n        stringValue = String.fromCodePoint(...new Uint16Array(arrayBuffer))\n      } else {\n        stringValue =\n          String.fromCodePoint(\n            ...new Uint16Array(arrayBuffer, 0, (arrayBuffer.byteLength - 1) / 2)\n          ) +\n          String.fromCodePoint(\n            new Uint8Array(arrayBuffer, arrayBuffer.byteLength - 1, 1)[0]\n          )\n      }\n    }\n    result += stringValue.length.toString(16) + ':' + stringValue\n  }\n  return result\n}\n\nfunction createTrackedReadableStream(\n  stream: ReadableStream,\n  cacheSignal: CacheSignal\n) {\n  const reader = stream.getReader()\n  return new ReadableStream({\n    async pull(controller) {\n      const { done, value } = await reader.read()\n      if (done) {\n        controller.close()\n        cacheSignal.endRead()\n      } else {\n        controller.enqueue(value)\n      }\n    },\n  })\n}\n\nexport async function cache(\n  kind: string,\n  id: string,\n  boundArgsLength: number,\n  originalFn: (...args: unknown[]) => Promise<unknown>,\n  argsObj: IArguments\n) {\n  let args = Array.prototype.slice.call(argsObj)\n\n  const isPrivate = kind === 'private'\n\n  // Private caches are currently only stored in the Resume Data Cache (RDC),\n  // and not in cache handlers.\n  const cacheHandler = isPrivate ? undefined : getCacheHandler(kind)\n\n  if (!isPrivate && !cacheHandler) {\n    throw new Error('Unknown cache handler: ' + kind)\n  }\n\n  const timeoutError = new UseCacheTimeoutError()\n  Error.captureStackTrace(timeoutError, cache)\n\n  const wrapAsInvalidDynamicUsageError = (\n    error: Error,\n    workStore: WorkStore\n  ) => {\n    Error.captureStackTrace(error, cache)\n    workStore.invalidDynamicUsageError ??= error\n\n    return error\n  }\n\n  const workStore = workAsyncStorage.getStore()\n  if (workStore === undefined) {\n    throw new Error(\n      '\"use cache\" cannot be used outside of App Router. Expected a WorkStore.'\n    )\n  }\n\n  const workUnitStore = workUnitAsyncStorage.getStore()\n  const name = originalFn.name\n  let fn = originalFn\n  let cacheContext: CacheContext\n\n  if (isPrivate) {\n    const expression = '\"use cache: private\"'\n\n    switch (workUnitStore?.type) {\n      // \"use cache: private\" is dynamic in prerendering contexts.\n      case 'prerender':\n        return makeHangingPromise(\n          workUnitStore.renderSignal,\n          workStore.route,\n          expression\n        )\n      case 'prerender-ppr':\n        return postponeWithTracking(\n          workStore.route,\n          expression,\n          workUnitStore.dynamicTracking\n        )\n      case 'prerender-legacy':\n        return throwToInterruptStaticGeneration(\n          expression,\n          workStore,\n          workUnitStore\n        )\n      case 'prerender-client':\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'unstable-cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \\`unstable_cache()\\`.`\n          ),\n          workStore\n        )\n      }\n      case 'cache': {\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} must not be used within \"use cache\". It can only be nested inside of another ${expression}.`\n          ),\n          workStore\n        )\n      }\n      case 'request':\n      case 'prerender-runtime':\n      case 'private-cache':\n        cacheContext = {\n          kind: 'private',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      case undefined:\n        throw wrapAsInvalidDynamicUsageError(\n          new Error(\n            // TODO: Add a link to an error documentation page when we have one.\n            `${expression} cannot be used outside of a request context.`\n          ),\n          workStore\n        )\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  } else {\n    switch (workUnitStore?.type) {\n      case 'prerender-client':\n        const expression = '\"use cache\"'\n        throw new InvariantError(\n          `${expression} must not be used within a client component. Next.js should be preventing ${expression} from being allowed in client components statically, but did not in this case.`\n        )\n      case 'prerender':\n      case 'prerender-runtime':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      // TODO: We should probably forbid nesting \"use cache\" inside\n      // unstable_cache. (fallthrough)\n      case 'unstable-cache':\n      case undefined:\n        cacheContext = {\n          kind: 'public',\n          outerWorkUnitStore: workUnitStore,\n        }\n        break\n      default:\n        workUnitStore satisfies never\n        // This is dead code, but without throwing an error here, TypeScript\n        // will assume that cacheContext is used before being assigned.\n        throw new InvariantError(`Unexpected work unit store.`)\n    }\n  }\n\n  // Get the clientReferenceManifest while we're still in the outer Context.\n  // In case getClientReferenceManifestSingleton is implemented using AsyncLocalStorage.\n  const clientReferenceManifest = getClientReferenceManifest()\n\n  // Because the Action ID is not yet unique per implementation of that Action we can't\n  // safely reuse the results across builds yet. In the meantime we add the buildId to the\n  // arguments as a seed to ensure they're not reused. Remove this once Action IDs hash\n  // the implementation.\n  const buildId = workStore.buildId\n\n  // In dev mode, when the HMR refresh hash is set, we include it in the\n  // cache key. This ensures that cache entries are not reused when server\n  // components have been edited. This is a very coarse approach. But it's\n  // also only a temporary solution until Action IDs are unique per\n  // implementation. Remove this once Action IDs hash the implementation.\n  const hmrRefreshHash =\n    workUnitStore && getHmrRefreshHash(workStore, workUnitStore)\n\n  const hangingInputAbortSignal = workUnitStore\n    ? createHangingInputAbortSignal(workUnitStore)\n    : undefined\n\n  if (cacheContext.kind === 'private') {\n    const { outerWorkUnitStore } = cacheContext\n    switch (outerWorkUnitStore.type) {\n      case 'prerender-runtime': {\n        // In a runtime prerender, we have to make sure that APIs that would hang during a static prerender\n        // are resolved with a delay, in the runtime stage. Private caches are one of these.\n        if (outerWorkUnitStore.runtimeStagePromise) {\n          await outerWorkUnitStore.runtimeStagePromise\n        }\n        break\n      }\n      case 'request': {\n        if (process.env.NODE_ENV === 'development') {\n          // Similar to runtime prerenders, private caches should not resolve in the static stage\n          // of a dev request, so we delay them.\n          await makeDevtoolsIOAwarePromise(\n            undefined,\n            outerWorkUnitStore,\n            RenderStage.Runtime\n          )\n        }\n        break\n      }\n      case 'private-cache':\n        break\n      default: {\n        outerWorkUnitStore satisfies never\n      }\n    }\n  }\n\n  let isPageOrLayoutSegmentFunction = false\n\n  // For page and layout segment functions (i.e. the page/layout component,\n  // or generateMetadata/generateViewport), the cache function is\n  // overwritten, which allows us to apply special handling for params and\n  // searchParams. For pages and layouts we're using the outer params prop,\n  // and not the inner one that was serialized/deserialized. While it's not\n  // generally true for \"use cache\" args, in the case of `params` the inner\n  // and outer object are essentially equivalent, so this is safe to do\n  // (including fallback params that are hanging promises). It allows us to\n  // avoid waiting for the timeout, when prerendering a fallback shell of a\n  // cached page or layout that awaits params.\n  if (isPageSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, searchParams: outerSearchParams },\n      ...otherOuterArgs\n    ] = args\n\n    const props: UseCachePageInnerProps = {\n      params: outerParams,\n      // Omit searchParams and $$isPage.\n    }\n\n    if (isPrivate) {\n      // Private caches allow accessing search params. We need to include\n      // them in the serialized args and when generating the cache key.\n      props.searchParams = outerSearchParams\n    }\n\n    args = [props, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          searchParams: innerSearchParams,\n        }: UseCachePageInnerProps,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          {\n            params: outerParams,\n            searchParams:\n              innerSearchParams ??\n              // For public caches, search params are omitted from the cache\n              // key (and the serialized args) to avoid mismatches between\n              // prerendering and resuming a cached page that does not\n              // access search params. This is also the reason why we're not\n              // using a hanging promise for search params. For cached pages\n              // that do access them, which is an invalid dynamic usage, we\n              // need to ensure that an error is shown.\n              makeErroringSearchParamsForUseCache(workStore),\n          },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  } else if (isLayoutSegmentFunction(args)) {\n    isPageOrLayoutSegmentFunction = true\n\n    const [\n      { params: outerParams, $$isLayout, ...outerSlots },\n      ...otherOuterArgs\n    ] = args\n\n    // Overwrite the props to omit $$isLayout. Note that slots are only\n    // passed to the layout component (if any are defined), and not to\n    // generateMetadata nor generateViewport. For those functions,\n    // outerSlots/innerSlots is an empty object, which is fine because we're\n    // just spreading it into the props.\n    args = [{ params: outerParams, ...outerSlots }, ...otherOuterArgs]\n\n    fn = {\n      [name]: async (\n        {\n          params: _innerParams,\n          ...innerSlots\n        }: Omit<UseCacheLayoutProps, '$$isLayout'>,\n        ...otherInnerArgs: unknown[]\n      ) =>\n        originalFn.apply(null, [\n          { params: outerParams, ...innerSlots },\n          ...otherInnerArgs,\n        ]),\n    }[name] as (...args: unknown[]) => Promise<unknown>\n  }\n\n  if (boundArgsLength > 0) {\n    if (args.length === 0) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive its encrypted bound arguments as the first argument.`\n      )\n    }\n\n    const encryptedBoundArgs = args.shift()\n    const boundArgs = await decryptActionBoundArgs(id, encryptedBoundArgs)\n\n    if (!Array.isArray(boundArgs)) {\n      throw new InvariantError(\n        `Expected the bound arguments of \"use cache\" function ${JSON.stringify(fn.name)} to deserialize into an array, got ${typeof boundArgs} instead.`\n      )\n    }\n\n    if (boundArgsLength !== boundArgs.length) {\n      throw new InvariantError(\n        `Expected the \"use cache\" function ${JSON.stringify(fn.name)} to receive ${boundArgsLength} bound arguments, got ${boundArgs.length} instead.`\n      )\n    }\n\n    args.unshift(boundArgs)\n  }\n\n  const temporaryReferences = createClientTemporaryReferenceSet()\n\n  // For private caches, which are allowed to read cookies, we still don't\n  // need to include the cookies in the cache key. This is because we don't\n  // store the cache entries in a cache handler, but only in the Resume Data\n  // Cache (RDC). Private caches are only used during dynamic requests and\n  // runtime prefetches. For dynamic requests, the RDC is immutable, so it\n  // does not include any private caches. For runtime prefetches, the RDC is\n  // mutable, but only lives as long as the request, so the key does not\n  // need to include cookies.\n  const cacheKeyParts: CacheKeyParts = hmrRefreshHash\n    ? [buildId, id, args, hmrRefreshHash]\n    : [buildId, id, args]\n\n  const encodeCacheKeyParts = () =>\n    encodeReply(cacheKeyParts, {\n      temporaryReferences,\n      signal: hangingInputAbortSignal,\n    })\n\n  let encodedCacheKeyParts: FormData | string\n\n  switch (workUnitStore?.type) {\n    case 'prerender-runtime':\n    // We're currently only using `dynamicAccessAsyncStorage` for params,\n    // which are always available in a runtime prerender, so they will never hang,\n    // effectively making the tracking below a no-op.\n    // However, a runtime prerender shares a lot of the semantics with a static prerender,\n    // and might need to follow this codepath in the future\n    // if we start using `dynamicAccessAsyncStorage` for other APIs.\n    //\n    // fallthrough\n    case 'prerender':\n      if (!isPageOrLayoutSegmentFunction) {\n        // If the \"use cache\" function is not a page or layout segment\n        // function, we need to track dynamic access already when encoding\n        // the arguments. If params are passed explicitly into a \"use cache\"\n        // function (as opposed to receiving them automatically in a page or\n        // layout), we assume that the params are also accessed. This allows\n        // us to abort early, and treat the function as dynamic, instead of\n        // waiting for the timeout to be reached.\n        const dynamicAccessAbortController = new AbortController()\n\n        encodedCacheKeyParts = await dynamicAccessAsyncStorage.run(\n          { abortController: dynamicAccessAbortController },\n          encodeCacheKeyParts\n        )\n\n        if (dynamicAccessAbortController.signal.aborted) {\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        }\n        break\n      }\n    // fallthrough\n    case 'prerender-ppr':\n    case 'prerender-legacy':\n    case 'request':\n    // TODO(restart-on-cache-miss): We need to handle params/searchParams on page components.\n    // the promises will be tasky, so `encodeCacheKeyParts` will not resolve in the static stage.\n    // We have not started a cache read at this point, so we might just miss the cache completely.\n    // fallthrough\n    case 'cache':\n    case 'private-cache':\n    case 'unstable-cache':\n    case undefined:\n      encodedCacheKeyParts = await encodeCacheKeyParts()\n      break\n    default:\n      return workUnitStore satisfies never\n  }\n\n  const serializedCacheKey =\n    typeof encodedCacheKeyParts === 'string'\n      ? // Fast path for the simple case for simple inputs. We let the CacheHandler\n        // Convert it to an ArrayBuffer if it wants to.\n        encodedCacheKeyParts\n      : await encodeFormData(encodedCacheKeyParts)\n\n  let stream: undefined | ReadableStream = undefined\n\n  // Get an immutable and mutable versions of the resume data cache.\n  const prerenderResumeDataCache = workUnitStore\n    ? getPrerenderResumeDataCache(workUnitStore)\n    : null\n  const renderResumeDataCache = workUnitStore\n    ? getRenderResumeDataCache(workUnitStore)\n    : null\n\n  if (renderResumeDataCache) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n\n    if (cacheSignal) {\n      cacheSignal.beginRead()\n    }\n    const cachedEntry = renderResumeDataCache.cache.get(serializedCacheKey)\n    if (cachedEntry !== undefined) {\n      const existingEntry = await cachedEntry\n      if (workUnitStore !== undefined && existingEntry !== undefined) {\n        if (\n          existingEntry.revalidate === 0 ||\n          existingEntry.expire < DYNAMIC_EXPIRE\n        ) {\n          switch (workUnitStore.type) {\n            case 'prerender':\n              // In a Dynamic I/O prerender, if the cache entry has\n              // revalidate: 0 or if the expire time is under 5 minutes,\n              // then we consider this cache entry dynamic as it's not worth\n              // generating static pages for such data. It's better to leave\n              // a dynamic hole that can be filled in during the resume with\n              // a potentially cached entry.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'prerender-runtime': {\n              // In the final phase of a runtime prerender, we have to make\n              // sure that APIs that would hang during a static prerender\n              // are resolved with a delay, in the runtime stage.\n              if (workUnitStore.runtimeStagePromise) {\n                await workUnitStore.runtimeStagePromise\n              }\n              break\n            }\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the static task --\n                // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Runtime\n                )\n              }\n              break\n            }\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n\n        if (existingEntry.stale < RUNTIME_PREFETCH_DYNAMIC_STALE) {\n          switch (workUnitStore.type) {\n            case 'prerender-runtime':\n              // In a runtime prerender, if the cache entry will become\n              // stale in less then 30 seconds, we consider this cache entry\n              // dynamic as it's not worth prefetching. It's better to leave\n              // a dynamic hole that can be filled during the navigation.\n              if (cacheSignal) {\n                cacheSignal.endRead()\n              }\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            case 'request': {\n              if (process.env.NODE_ENV === 'development') {\n                // We delay the cache here so that it doesn't resolve in the runtime phase --\n                // in a regular runtime prerender, it'd be a hanging promise, and we need to reflect that,\n                // so it has to resolve later.\n                // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n                // We don't end the cache read here, so this will always appear as a cache miss in the runtime stage,\n                // and thus will cause a restart even if all caches are filled.\n                await makeDevtoolsIOAwarePromise(\n                  undefined,\n                  workUnitStore,\n                  RenderStage.Dynamic\n                )\n              }\n              break\n            }\n            case 'prerender':\n            case 'prerender-ppr':\n            case 'prerender-legacy':\n            case 'cache':\n            case 'private-cache':\n            case 'unstable-cache':\n              break\n            default:\n              workUnitStore satisfies never\n          }\n        }\n      }\n\n      // We want to make sure we only propagate cache life & tags if the\n      // entry was *not* omitted from the prerender. So we only do this\n      // after the above early returns.\n      propagateCacheLifeAndTags(cacheContext, existingEntry)\n\n      const [streamA, streamB] = existingEntry.value.tee()\n      existingEntry.value = streamB\n\n      if (cacheSignal) {\n        // When we have a cacheSignal we need to block on reading the cache\n        // entry before ending the read.\n        stream = createTrackedReadableStream(streamA, cacheSignal)\n      } else {\n        stream = streamA\n      }\n    } else {\n      if (cacheSignal) {\n        cacheSignal.endRead()\n      }\n\n      if (workUnitStore) {\n        switch (workUnitStore.type) {\n          case 'prerender':\n            // If `allowEmptyStaticShell` is true, and thus a prefilled\n            // resume data cache was provided, then a cache miss means that\n            // params were part of the cache key. In this case, we can make\n            // this cache function a dynamic hole in the shell (or produce\n            // an empty shell if there's no parent suspense boundary).\n            // Currently, this also includes layouts and pages that don't\n            // read params, which will be improved when we implement\n            // NAR-136. Otherwise, we assume that if params are passed\n            // explicitly into a \"use cache\" function, that the params are\n            // also accessed. This allows us to abort early, and treat the\n            // function as dynamic, instead of waiting for the timeout to be\n            // reached. Compared to the instrumentation-based params bailout\n            // we do here, this also covers the case where params are\n            // transformed with an async function, before being passed into\n            // the \"use cache\" function, which escapes the instrumentation.\n            if (workUnitStore.allowEmptyStaticShell) {\n              return makeHangingPromise(\n                workUnitStore.renderSignal,\n                workStore.route,\n                'dynamic \"use cache\"'\n              )\n            }\n            break\n          case 'prerender-runtime':\n          case 'prerender-ppr':\n          case 'prerender-legacy':\n          case 'request':\n          case 'cache':\n          case 'private-cache':\n          case 'unstable-cache':\n            break\n          default:\n            workUnitStore satisfies never\n        }\n      }\n    }\n  }\n\n  if (stream === undefined) {\n    const cacheSignal = workUnitStore ? getCacheSignal(workUnitStore) : null\n    if (cacheSignal) {\n      // Either the cache handler or the generation can be using I/O at this point.\n      // We need to track when they start and when they complete.\n      cacheSignal.beginRead()\n    }\n\n    const lazyRefreshTags = workStore.refreshTagsByCacheKind.get(kind)\n\n    if (lazyRefreshTags && !isResolvedLazyResult(lazyRefreshTags)) {\n      await lazyRefreshTags\n    }\n\n    let entry: CacheEntry | undefined\n\n    // We ignore existing cache entries when force revalidating.\n    if (cacheHandler && !shouldForceRevalidate(workStore, workUnitStore)) {\n      entry = await cacheHandler.get(\n        serializedCacheKey,\n        workUnitStore?.implicitTags?.tags ?? []\n      )\n    }\n\n    if (entry) {\n      const implicitTags = workUnitStore?.implicitTags?.tags ?? []\n      let implicitTagsExpiration = 0\n\n      if (workUnitStore?.implicitTags) {\n        const lazyExpiration =\n          workUnitStore.implicitTags.expirationsByCacheKind.get(kind)\n\n        if (lazyExpiration) {\n          const expiration = isResolvedLazyResult(lazyExpiration)\n            ? lazyExpiration.value\n            : await lazyExpiration\n\n          // If a cache handler returns an expiration time of Infinity, it\n          // signals to Next.js that it handles checking cache entries for\n          // staleness based on the expiration of the implicit tags passed\n          // into the `get` method. In this case, we keep the default of 0,\n          // which means that the implicit tags are not considered expired.\n          if (expiration < Infinity) {\n            implicitTagsExpiration = expiration\n          }\n        }\n      }\n\n      if (\n        shouldDiscardCacheEntry(\n          entry,\n          workStore,\n          workUnitStore,\n          implicitTags,\n          implicitTagsExpiration\n        )\n      ) {\n        debug?.('discarding expired entry', serializedCacheKey)\n        entry = undefined\n      }\n    }\n\n    const currentTime = performance.timeOrigin + performance.now()\n    if (\n      workUnitStore !== undefined &&\n      entry !== undefined &&\n      (entry.revalidate === 0 || entry.expire < DYNAMIC_EXPIRE)\n    ) {\n      switch (workUnitStore.type) {\n        case 'prerender':\n          // In a Dynamic I/O prerender, if the cache entry has revalidate:\n          // 0 or if the expire time is under 5 minutes, then we consider\n          // this cache entry dynamic as it's not worth generating static\n          // pages for such data. It's better to leave a dynamic hole that\n          // can be filled in during the resume with a potentially cached\n          // entry.\n          if (cacheSignal) {\n            cacheSignal.endRead()\n          }\n          return makeHangingPromise(\n            workUnitStore.renderSignal,\n            workStore.route,\n            'dynamic \"use cache\"'\n          )\n        case 'request': {\n          if (process.env.NODE_ENV === 'development') {\n            // We delay the cache here so that it doesn't resolve in the static task --\n            // in a regular static prerender, it'd be a hanging promise, and we need to reflect that,\n            // so it has to resolve later.\n            // TODO(restart-on-cache-miss): Optimize this to avoid unnecessary restarts.\n            // We don't end the cache read here, so this will always appear as a cache miss in the static stage,\n            // and thus will cause a restart even if all caches are filled.\n            await makeDevtoolsIOAwarePromise(\n              undefined,\n              workUnitStore,\n              RenderStage.Runtime\n            )\n          }\n          break\n        }\n        case 'prerender-runtime':\n        case 'prerender-ppr':\n        case 'prerender-legacy':\n        case 'cache':\n        case 'private-cache':\n        case 'unstable-cache':\n          break\n        default:\n          workUnitStore satisfies never\n      }\n    }\n\n    if (\n      entry === undefined ||\n      currentTime > entry.timestamp + entry.expire * 1000 ||\n      (workStore.isStaticGeneration &&\n        currentTime > entry.timestamp + entry.revalidate * 1000)\n    ) {\n      // Miss. Generate a new result.\n\n      // If the cache entry is stale and we're prerendering, we don't want to use the\n      // stale entry since it would unnecessarily need to shorten the lifetime of the\n      // prerender. We're not time constrained here so we can re-generated it now.\n\n      // We need to run this inside a clean AsyncLocalStorage snapshot so that the cache\n      // generation cannot read anything from the context we're currently executing which\n      // might include request specific things like cookies() inside a React.cache().\n      // Note: It is important that we await at least once before this because it lets us\n      // pop out of any stack specific contexts as well - aka \"Sync\" Local Storage.\n\n      if (entry) {\n        if (currentTime > entry.timestamp + entry.expire * 1000) {\n          debug?.('entry is expired', serializedCacheKey)\n        }\n\n        if (\n          workStore.isStaticGeneration &&\n          currentTime > entry.timestamp + entry.revalidate * 1000\n        ) {\n          debug?.('static generation, entry is stale', serializedCacheKey)\n        }\n      }\n\n      const result = await generateCacheEntry(\n        workStore,\n        cacheContext,\n        clientReferenceManifest,\n        encodedCacheKeyParts,\n        fn,\n        timeoutError\n      )\n\n      if (result.type === 'prerender-dynamic') {\n        return result.hangingPromise\n      }\n\n      const { stream: newStream, pendingCacheEntry } = result\n\n      // When draft mode is enabled, we must not save the cache entry.\n      if (!workStore.isDraftMode) {\n        let savedCacheEntry\n\n        if (prerenderResumeDataCache) {\n          // Create a clone that goes into the cache scope memory cache.\n          const split = clonePendingCacheEntry(pendingCacheEntry)\n          savedCacheEntry = getNthCacheEntry(split, 0)\n          prerenderResumeDataCache.cache.set(\n            serializedCacheKey,\n            getNthCacheEntry(split, 1)\n          )\n        } else {\n          savedCacheEntry = pendingCacheEntry\n        }\n\n        if (cacheHandler) {\n          const promise = cacheHandler.set(serializedCacheKey, savedCacheEntry)\n\n          workStore.pendingRevalidateWrites ??= []\n          workStore.pendingRevalidateWrites.push(promise)\n        }\n      }\n\n      stream = newStream\n    } else {\n      // If we have an entry at this point, this can't be a private cache\n      // entry.\n      if (cacheContext.kind === 'private') {\n        throw new InvariantError(\n          `A private cache entry must not be retrieved from the cache handler.`\n        )\n      }\n\n      propagateCacheLifeAndTags(cacheContext, entry)\n\n      // We want to return this stream, even if it's stale.\n      stream = entry.value\n\n      // If we have a cache scope, we need to clone the entry and set it on\n      // the inner cache scope.\n      if (prerenderResumeDataCache) {\n        const [entryLeft, entryRight] = cloneCacheEntry(entry)\n        if (cacheSignal) {\n          stream = createTrackedReadableStream(entryLeft.value, cacheSignal)\n        } else {\n          stream = entryLeft.value\n        }\n\n        prerenderResumeDataCache.cache.set(\n          serializedCacheKey,\n          Promise.resolve(entryRight)\n        )\n      } else {\n        // If we're not regenerating we need to signal that we've finished\n        // putting the entry into the cache scope at this point. Otherwise we do\n        // that inside generateCacheEntry.\n        cacheSignal?.endRead()\n      }\n\n      if (currentTime > entry.timestamp + entry.revalidate * 1000) {\n        // If this is stale, and we're not in a prerender (i.e. this is\n        // dynamic render), then we should warm up the cache with a fresh\n        // revalidated entry.\n        const result = await generateCacheEntry(\n          workStore,\n          // This is not running within the context of this unit.\n          { kind: cacheContext.kind, outerWorkUnitStore: undefined },\n          clientReferenceManifest,\n          encodedCacheKeyParts,\n          fn,\n          timeoutError\n        )\n\n        if (result.type === 'cached') {\n          const { stream: ignoredStream, pendingCacheEntry } = result\n          let savedCacheEntry: Promise<CacheEntry>\n\n          if (prerenderResumeDataCache) {\n            const split = clonePendingCacheEntry(pendingCacheEntry)\n            savedCacheEntry = getNthCacheEntry(split, 0)\n            prerenderResumeDataCache.cache.set(\n              serializedCacheKey,\n              getNthCacheEntry(split, 1)\n            )\n          } else {\n            savedCacheEntry = pendingCacheEntry\n          }\n\n          if (cacheHandler) {\n            const promise = cacheHandler.set(\n              serializedCacheKey,\n              savedCacheEntry\n            )\n\n            workStore.pendingRevalidateWrites ??= []\n            workStore.pendingRevalidateWrites.push(promise)\n          }\n\n          await ignoredStream.cancel()\n        }\n      }\n    }\n  }\n\n  // Logs are replayed even if it's a hit - to ensure we see them on the client eventually.\n  // If we didn't then the client wouldn't see the logs if it was seeded from a prewarm that\n  // never made it to the client. However, this also means that you see logs even when the\n  // cached function isn't actually re-executed. We should instead ensure prewarms always\n  // make it to the client. Another issue is that this will cause double logging in the\n  // server terminal. Once while generating the cache entry and once when replaying it on\n  // the server, which is required to pick it up for replaying again on the client.\n  const replayConsoleLogs = true\n\n  const serverConsumerManifest = {\n    // moduleLoading must be null because we don't want to trigger preloads of ClientReferences\n    // to be added to the consumer. Instead, we'll wait for any ClientReference to be emitted\n    // which themselves will handle the preloading.\n    moduleLoading: null,\n    moduleMap: isEdgeRuntime\n      ? clientReferenceManifest.edgeRscModuleMapping\n      : clientReferenceManifest.rscModuleMapping,\n    serverModuleMap: getServerModuleMap(),\n  }\n\n  return createFromReadableStream(stream, {\n    findSourceMapURL,\n    serverConsumerManifest,\n    temporaryReferences,\n    replayConsoleLogs,\n    environmentName: 'Cache',\n  })\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the page component itself,\n * or `generateMetadata`/`generateViewport` in a page file.\n */\nfunction isPageSegmentFunction(\n  args: any[]\n): args is [UseCachePageProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCachePageProps).$$isPage === true\n  )\n}\n\n/**\n * Returns `true` if the `'use cache'` function is the layout component itself,\n * or `generateMetadata`/`generateViewport` in a layout file.\n */\nfunction isLayoutSegmentFunction(\n  args: any[]\n): args is [UseCacheLayoutProps, ...unknown[]] {\n  const [maybeProps] = args\n\n  return (\n    maybeProps !== null &&\n    typeof maybeProps === 'object' &&\n    (maybeProps as UseCacheLayoutProps).$$isLayout === true\n  )\n}\n\nfunction shouldForceRevalidate(\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined\n): boolean {\n  if (workStore.isOnDemandRevalidate || workStore.isDraftMode) {\n    return true\n  }\n\n  if (workStore.dev && workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'request':\n        return workUnitStore.headers.get('cache-control') === 'no-cache'\n      case 'cache':\n      case 'private-cache':\n        return workUnitStore.forceRevalidate\n      case 'prerender-runtime':\n      case 'prerender':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  return false\n}\n\nfunction shouldDiscardCacheEntry(\n  entry: CacheEntry,\n  workStore: WorkStore,\n  workUnitStore: WorkUnitStore | undefined,\n  implicitTags: string[],\n  implicitTagsExpiration: number\n): boolean {\n  // If the cache entry was created before any of the implicit tags were\n  // revalidated last, we need to discard it.\n  if (entry.timestamp <= implicitTagsExpiration) {\n    debug?.(\n      'entry was created at',\n      entry.timestamp,\n      'before implicit tags were revalidated at',\n      implicitTagsExpiration\n    )\n\n    return true\n  }\n\n  // During prerendering, we ignore recently revalidated tags. In dev mode, we\n  // can assume that the dynamic dev rendering will have discarded and recreated\n  // the affected cache entries, and we don't want to discard those again during\n  // the prerender validation. During build-time prerendering, there will never\n  // be any pending revalidated tags.\n  if (workUnitStore) {\n    switch (workUnitStore.type) {\n      case 'prerender':\n        return false\n      case 'prerender-runtime':\n      case 'prerender-client':\n      case 'prerender-ppr':\n      case 'prerender-legacy':\n      case 'request':\n      case 'cache':\n      case 'private-cache':\n      case 'unstable-cache':\n        break\n      default:\n        workUnitStore satisfies never\n    }\n  }\n\n  // If the cache entry contains revalidated tags that the cache handler might\n  // not know about yet, we need to discard it.\n  if (entry.tags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  // Finally, if any of the implicit tags have been revalidated recently, we\n  // also need to discard the cache entry.\n  if (implicitTags.some((tag) => isRecentlyRevalidatedTag(tag, workStore))) {\n    return true\n  }\n\n  return false\n}\n\nfunction isRecentlyRevalidatedTag(tag: string, workStore: WorkStore): boolean {\n  const { previouslyRevalidatedTags, pendingRevalidatedTags } = workStore\n\n  // Was the tag previously revalidated (e.g. by a redirecting server action)?\n  if (previouslyRevalidatedTags.includes(tag)) {\n    debug?.('tag', tag, 'was previously revalidated')\n\n    return true\n  }\n\n  // It could also have been revalidated by the currently running server action.\n  // In this case the revalidation might not have been fully propagated by a\n  // remote cache handler yet, so we read it from the pending tags in the work\n  // store.\n  if (pendingRevalidatedTags?.some((item) => item.tag === tag)) {\n    debug?.('tag', tag, 'was just revalidated')\n\n    return true\n  }\n\n  return false\n}\n","export { cache } from '../../../../server/use-cache/use-cache-wrapper'\n"],"names":["getClientReferenceManifest","getServerActionsManifest","getServerModuleMap","selectWorkerForForwarding","setManifestsSingleton","MANIFESTS_SINGLETON","Symbol","for","globalThisWithManifests","globalThis","createProxiedClientReferenceManifest","clientReferenceManifestsPerRoute","createMappingProxy","prop","Proxy","get","_","id","workStore","workAsyncStorage","getStore","currentManifest","route","process","env","NODE_ENV","manifest","entry","undefined","values","mappingProxies","Map","InvariantError","proxy","set","String","createServerModuleMap","workers","NEXT_RUNTIME","workerEntry","normalizeWorkerPageName","page","Object","at","moduleId","async","name","chunks","pageName","pathHasPrefix","denormalizeWorkerPageName","bundlePath","normalizeAppPath","removePathPrefix","actionId","serverActionsManifest","keys","clientReferenceManifest","existingSingleton","proxiedClientReferenceManifest","serverModuleMap","getManifestsSingleton","manifestSingleton","arrayBufferToString","decrypt","encrypt","getActionEncryptionKey","stringToUint8Array","__next_loaded_action_key","buffer","bytes","Uint8Array","len","byteLength","fromCharCode","apply","binary","i","length","arr","charCodeAt","key","iv","data","crypto","subtle","rawKey","NEXT_SERVER_ACTIONS_ENCRYPTION_KEY","encryptionKey","importKey","atob","decryptActionBoundArgs","encryptActionBoundArgs","isEdgeRuntime","textEncoder","TextEncoder","textDecoder","TextDecoder","filterStackFrame","require","filterStackFrameDEV","findSourceMapURL","findSourceMapURLDEV","decodeActionBoundArg","arg","Error","originalPayload","ivValue","slice","payload","decrypted","decode","startsWith","encodeActionBoundArg","randomBytes","workUnitAsyncStorage","exit","getRandomValues","encrypted","encode","btoa","ReadStatus","React","cache","args","workUnitStore","cacheSignal","getCacheSignal","clientModules","error","captureStackTrace","didCatchError","hangingInputAbortSignal","createHangingInputAbortSignal","readStatus","startReadOnce","beginRead","endReadIfStarted","endRead","addEventListener","once","serialized","streamToString","renderToReadableStream","signal","onError","err","aborted","message","console","prerenderResumeDataCache","getPrerenderResumeDataCache","renderResumeDataCache","getRenderResumeDataCache","cacheKey","cachedEncrypted","encryptedBoundArgs","encryptedPromise","decryptedBoundArgs","edgeRscModuleMapping","rscModuleMapping","deserialized","createFromReadableStream","ReadableStream","start","controller","enqueue","type","renderSignal","close","serverConsumerManifest","moduleLoading","moduleMap","formatServerError","getStackWithoutErrorMessage","invalidServerComponentReactHooks","setMessage","stack","lines","split","join","replace","includes","addedMessage","clientHook","regex","RegExp","test","getObjectClassLabel","isPlainObject","value","prototype","toString","call","getPrototypeOf","hasOwnProperty","isError","getProperError","safeStringifyLite","obj","seen","WeakSet","JSON","stringify","_key","has","add","createDigestWithErrorCode","extractNextErrorCode","ERROR_CODE_DELIMITER","thrownValue","originalDigest","__NEXT_ERROR_CODE","digest","segments","errorCode","find","segment","isReactLargeShellError","createHTMLErrorHandler","createReactServerErrorHandler","getDigestForWellKnownError","isUserLandError","isBailoutToCSRError","isNextRouterError","isDynamicServerError","isPrerenderInterruptedError","shouldFormatError","isNextExport","reactServerErrors","onReactServerRenderError","spanToRecordOn","stringHash","isAbortError","silenceLog","span","getTracer","getActiveScopeSpan","recordException","setAttribute","setStatus","code","SpanStatusCode","ERROR","allCapturedErrors","onHTMLRenderSSRError","errorInfo","isSSRError","push","componentStack","DYNAMIC_EXPIRE","RUNTIME_PREFETCH_DYNAMIC_STALE","LRUCache","LRUNode","constructor","size","prev","next","SentinelNode","maxSize","calculateSize","totalSize","head","tail","addToHead","node","removeNode","moveToHead","removeTail","lastNode","warn","existing","newNode","delete","iterator","current","remove","currentSize","createDefaultCacheHandler","Promise","resolve","refreshTags","getExpiration","updateTags","memoryCache","pendingSets","debug","NEXT_PRIVATE_DEBUG_CACHE","bind","pendingPromise","privateEntry","performance","timeOrigin","now","timestamp","revalidate","areTagsExpired","tags","areTagsStale","returnStream","newSaved","tee","expire","pendingEntry","resolvePending","clonedValue","reader","getReader","chunk","read","done","Buffer","from","isErrored","errorRetryCount","expirations","map","tag","tagsManifest","expired","expiration","Math","max","durations","round","existingEntry","updates","stale","getCacheHandler","getCacheHandlerEntries","getCacheHandlers","initializeCacheHandlers","setCacheHandler","log","handlersSymbol","handlersMapSymbol","handlersSetSymbol","reference","cacheMaxMemorySize","fallback","DefaultCache","RemoteCache","handler","Set","kind","entries","cacheHandler","UseCacheTimeoutError","isUseCacheTimeoutError","USE_CACHE_TIMEOUT_ERROR_CODE","describeHasCheckingStringProperty","describeStringPropertyAccess","wellKnownProperties","isDefinitelyAValidIdentifier","target","stringifiedProp","createPrerenderSearchParamsForClientPage","createSearchParamsFromClient","createServerSearchParamsForMetadata","createServerSearchParamsForServerPage","makeErroringSearchParamsForUseCache","underlyingSearchParams","createStaticPrerenderSearchParams","createRenderSearchParams","throwInvariantForMissingStore","createRuntimePrerenderSearchParams","forceStatic","makeHangingPromise","prerenderStore","makeHangingSearchParams","makeErroringSearchParams","delayUntilRuntimeStage","makeUntrackedSearchParams","requestStore","makeUntrackedSearchParamsWithDevWarnings","CachedSearchParams","WeakMap","CachedSearchParamsForUseCache","cachedSearchParams","promise","proxiedPromise","receiver","hasOwn","ReflectAdapter","expression","annotateDynamicAccess","dynamicShouldError","throwWithStaticGenerationBailoutErrorWithDynamicError","postponeWithTracking","dynamicTracking","throwToInterruptStaticGeneration","throwForSearchParamsAccessInUseCache","asyncApiPromises","makeUntrackedSearchParamsWithDevWarningsImpl","promiseInitialized","proxiedUnderlying","instrumentSearchParamsObjectWithDevWarnings","sharedSearchParamsParent","reject","then","displayName","makeDevtoolsIOAwarePromise","RenderStage","Runtime","ignoreReject","instrumentSearchParamsPromiseWithDevWarnings","Reflect","ownKeys","proxiedProperties","forEach","warnForSyncAccess","createDedupedByCallsiteServerErrorLoggerDev","createSearchAccessError","prefix","createLazyResult","isResolvedLazyResult","fn","pendingResult","result","onfulfilled","onrejected","catch","bgBlack","bgBlue","bgCyan","bgGreen","bgMagenta","bgRed","bgWhite","bgYellow","black","blue","bold","cyan","dim","gray","green","hidden","inverse","italic","magenta","purple","red","reset","strikethrough","underline","white","yellow","stdout","enabled","NO_COLOR","FORCE_COLOR","isTTY","CI","TERM","replaceClose","str","index","substring","end","nextIndex","indexOf","formatter","open","input","string","s","bootstrap","errorOnce","event","info","prefixes","ready","trace","wait","warnOnce","LOGGING_METHOD","prefixedLog","prefixType","shift","consoleMethod","warnOnceCache","errorOnceCache","generateCacheEntry","cacheContext","encodedArguments","timeoutError","runInCleanSnapshot","generateCacheEntryWithRestoredWorkStore","run","generateCacheEntryWithCacheContext","createUseCacheStore","defaultCacheLife","outerWorkUnitStore","phase","implicitTags","explicitRevalidate","explicitExpire","explicitStale","hmrRefreshHash","getHmrRefreshHash","isHmrRefresh","serverComponentsHmrCache","getServerComponentsHmrCache","forceRevalidate","shouldForceRevalidate","runtimeStagePromise","getRuntimeStagePromise","draftMode","getDraftModeProviderForCacheScope","rootParams","headers","cookies","useCacheOrRequestStore","assertDefaultCacheLife","cacheLifeProfiles","cacheStore","dynamicAccessAsyncStorage","abortController","AbortController","generateCacheEntryImpl","propagateCacheLifeAndTagsToRevalidateStore","revalidateStore","outerTags","propagateCacheLifeAndTags","collectResult","savedStream","innerCacheStore","startTime","errors","idx","bufferStream","pull","invalidDynamicUsageError","collectedTags","collectedRevalidate","collectedExpire","collectedStale","temporaryReferences","createServerTemporaryReferenceSet","decodeReply","decodeReplyFromAsyncIterable","asyncIterator","resultPromise","handleError","dev","isBuildTimePrerendering","reactServerErrorsByDigest","Log","stream","timeoutAbortController","timer","setTimeout","abort","dynamicAccessAbortSignal","abortSignal","AbortSignal","any","prelude","prerender","environmentName","reason","clearTimeout","hangingPromise","pendingCacheEntry","cloneCacheEntry","streamA","streamB","clonedEntry","clonePendingCacheEntry","getNthCacheEntry","encodeFormData","formData","stringValue","arrayBuffer","fromCodePoint","Uint16Array","createTrackedReadableStream","boundArgsLength","originalFn","argsObj","Array","isPrivate","wrapAsInvalidDynamicUsageError","buildId","isPageOrLayoutSegmentFunction","isPageSegmentFunction","params","outerParams","searchParams","outerSearchParams","otherOuterArgs","props","_innerParams","innerSearchParams","otherInnerArgs","isLayoutSegmentFunction","$$isLayout","outerSlots","innerSlots","boundArgs","isArray","unshift","createClientTemporaryReferenceSet","cacheKeyParts","encodeCacheKeyParts","encodeReply","encodedCacheKeyParts","dynamicAccessAbortController","serializedCacheKey","cachedEntry","Dynamic","allowEmptyStaticShell","lazyRefreshTags","refreshTagsByCacheKind","implicitTagsExpiration","lazyExpiration","expirationsByCacheKind","Infinity","shouldDiscardCacheEntry","currentTime","isStaticGeneration","newStream","isDraftMode","savedCacheEntry","pendingRevalidateWrites","entryLeft","entryRight","ignoredStream","cancel","replayConsoleLogs","maybeProps","$$isPage","isOnDemandRevalidate","some","isRecentlyRevalidatedTag","previouslyRevalidatedTags","pendingRevalidatedTags","item"],"mappings":"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","ignoreList":[0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,20]}