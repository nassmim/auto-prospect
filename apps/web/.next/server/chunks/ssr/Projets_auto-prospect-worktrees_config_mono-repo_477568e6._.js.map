{"version":3,"sources":["../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/src/services/lead.service.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/src/lib/worker-client.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/src/actions/message.actions.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/src/utils/crypto.utils.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/src/actions/lead.actions.ts","../../../../../../../../../../Projets/auto-prospect-worktrees/config/mono-repo/apps/web/.next-internal/server/app/dashboard/leads/page/actions.js%20%28server%20actions%20loader%29"],"sourcesContent":["import { createDrizzleSupabaseClient } from \"@/lib/db\";\nimport type { SQL, TDBQuery, TDBWithTokenClient } from \"@auto-prospect/db\";\nimport { and, eq, gte, leads, messages, sql } from \"@auto-prospect/db\";\nimport { ELeadStage } from \"@auto-prospect/shared/src/config/lead.config\";\n\ntype TLeadsSummaryStats = {\n  todayLeadsCount: number;\n  contactedLeadsCount: number;\n  totalLeads: number;\n};\n\n/**\n * Fetch complete lead details with all relations\n * Used by lead drawer and full page view\n */\nexport async function getLeadDetails(leadId: string) {\n  // This function can be cached\n  // Will be invalidated when the user performs an action on this specific lead\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    // Fetch lead with all ad relations\n    const leadData = await dbClient.rls(async (tx) => {\n      return tx.query.leads.findFirst({\n        where: eq(leads.id, leadId),\n        with: {\n          ad: {\n            with: {\n              brand: true,\n              fuel: true,\n              gearBox: true,\n              location: true,\n              type: true,\n              subtype: true,\n              vehicleState: true,\n              vehicleSeats: true,\n              drivingLicence: true,\n            },\n          },\n          assignedTo: {\n            columns: {\n              id: true,\n              name: true,\n            },\n          },\n          notes: {\n            orderBy: (notes, { desc }) => [desc(notes.createdAt)],\n          },\n          reminders: {\n            orderBy: (reminders, { asc }) => [asc(reminders.dueAt)],\n          },\n        },\n      });\n    });\n\n    if (!leadData) {\n      throw new Error(\"Lead not found\");\n    }\n\n    return leadData;\n  } catch (error) {\n    console.error(\"Error fetching lead details:\", error);\n    throw new Error(\"Failed to fetch lead details\");\n  }\n}\n\n/**\n * Fetch all members of the lead's account for assignment dropdown\n */\nexport async function getLeadAssociatedTeamMembers(leadId: string) {\n  // This function can be cached\n  // Will be invalidated when the user associates another member or removes the member association\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    // First, get the lead's account\n    const lead = await dbClient.rls((tx) =>\n      tx.query.leads.findFirst({\n        where: eq(leads.id, leadId),\n        columns: {\n          accountId: true,\n        },\n      }),\n    );\n\n    if (!lead) {\n      throw new Error(\"Lead not found\");\n    }\n\n    // Fetch all members of this account\n    return await dbClient.rls((tx) =>\n      tx.query.teamMembers.findMany({\n        where: (table, { eq }) => eq(table.accountId, lead.accountId),\n      }),\n    );\n  } catch {\n    throw new Error(\"Failed to fetch account members\");\n  }\n}\n\n/**\n * Fetch message history for a lead\n */\nexport async function getLeadMessages(leadId: string) {\n  // This function can be cached\n  // Will be invalidated when the user sends a new message to this lead\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const messagesList = await dbClient.rls(async (tx) => {\n      return tx.query.messages.findMany({\n        where: eq(messages.leadId, leadId),\n        with: {\n          sentBy: {\n            columns: {\n              id: true,\n              name: true,\n            },\n          },\n        },\n        orderBy: (table, { desc }) => [desc(table.sentAt)],\n      });\n    });\n\n    return messagesList;\n  } catch {\n    throw new Error(\"Failed to fetch messages\");\n  }\n}\n\n/**\n * Fetch activity timeline for a lead\n */\nexport async function getLeadActivities(leadId: string) {\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const activitiesList = await dbClient.rls(async (tx) => {\n      return tx.query.leadActivities.findMany({\n        where: (table, { eq }) => eq(table.leadId, leadId),\n        with: {\n          lead: {\n            with: {\n              assignedTo: {\n                columns: {\n                  id: true,\n                  name: true,\n                },\n              },\n            },\n          },\n        },\n        orderBy: (table, { desc }) => [desc(table.createdAt)],\n      });\n    });\n\n    return activitiesList;\n  } catch {\n    throw new Error(\"Failed to fetch activities\");\n  }\n}\n\n/**\n * Fetches leads acquired today\n */\nexport async function getTodayNewLeads(options?: {\n  huntId?: string;\n  dbClient?: TDBWithTokenClient;\n  tx?: TDBQuery;\n}): Promise<{ todayLeadsCount: number }> {\n  const { huntId, dbClient, tx } = options || {};\n\n  const today = new Date();\n  today.setHours(0, 0, 0, 0);\n\n  // Build where conditions dynamically based on whether huntId is provided\n  const whereConditions = [gte(leads.createdAt, today)];\n\n  if (huntId) {\n    whereConditions.push(eq(leads.huntId, huntId));\n  }\n\n  // If transaction provided, use it directly; otherwise create new RLS transaction\n  if (tx) {\n    const todayLeads = await tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(and(...whereConditions));\n\n    return {\n      todayLeadsCount: todayLeads[0]?.count ?? 0,\n    };\n  }\n\n  const client = dbClient || (await createDrizzleSupabaseClient());\n  const todayLeads = await client.rls(async (tx) =>\n    tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(and(...whereConditions)),\n  );\n\n  return {\n    todayLeadsCount: todayLeads[0]?.count ?? 0,\n  };\n}\n\n/**\n * Fetches the number of leads contacted\n */\nexport async function getContactedLeads(options?: {\n  huntId?: string;\n  dbClient?: TDBWithTokenClient;\n  tx?: TDBQuery;\n}): Promise<{ contactedLeadsCount: number }> {\n  const { huntId, dbClient, tx } = options || {};\n\n  // Build where conditions dynamically based on whether huntId is provided\n  const whereConditions = [eq(leads.stage, ELeadStage.CONTACTED)];\n\n  if (huntId) {\n    whereConditions.push(eq(leads.huntId, huntId));\n  }\n\n  // If transaction provided, use it directly; otherwise create new RLS transaction\n  if (tx) {\n    const contactedLeads = await tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(and(...whereConditions));\n\n    return {\n      contactedLeadsCount: contactedLeads[0]?.count ?? 0,\n    };\n  }\n\n  const client = dbClient || (await createDrizzleSupabaseClient());\n  const contactedLeads = await client.rls(async (tx) =>\n    tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(and(...whereConditions)),\n  );\n\n  return {\n    contactedLeadsCount: contactedLeads[0]?.count ?? 0,\n  };\n}\n\n/**\n * Fetches the total number of leads\n */\nexport async function getTotalLeads(options?: {\n  huntId?: string;\n  dbClient?: TDBWithTokenClient;\n  tx?: TDBQuery;\n}): Promise<{ totalLeads: number }> {\n  const { huntId, dbClient, tx } = options || {};\n\n  // Build where conditions dynamically based on whether huntId is provided\n  let whereConditions: SQL<unknown> | undefined;\n  if (huntId) whereConditions = eq(leads.huntId, huntId);\n\n  // If transaction provided, use it directly; otherwise create new RLS transaction\n  if (tx) {\n    const totalLeads = await tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(whereConditions);\n\n    return {\n      totalLeads: totalLeads[0]?.count ?? 0,\n    };\n  }\n\n  const client = dbClient || (await createDrizzleSupabaseClient());\n  const totalLeads = await client.rls(async (tx) =>\n    tx\n      .select({ count: sql<number>`cast(count(*) as integer)` })\n      .from(leads)\n      .where(whereConditions),\n  );\n\n  return {\n    totalLeads: totalLeads[0]?.count ?? 0,\n  };\n}\n\n/**\n * Fetches summary statistics for leads\n * @param huntId - Optional hunt ID to filter by specific hunt. If not provided, returns global stats for all hunts.\n */\nexport async function getLeadsSummaryStats(\n  huntId?: string,\n): Promise<TLeadsSummaryStats> {\n  const dbClient = await createDrizzleSupabaseClient();\n\n  const summaryStats = await Promise.all([\n    getTodayNewLeads({ huntId, dbClient }),\n    getContactedLeads({ huntId, dbClient }),\n    getTotalLeads({ huntId, dbClient }),\n  ]);\n\n  return {\n    todayLeadsCount: summaryStats[0].todayLeadsCount,\n    contactedLeadsCount: summaryStats[1].contactedLeadsCount,\n    totalLeads: summaryStats[2].totalLeads,\n  };\n}\n\n/**\n * Fetches all leads for the pipeline/kanban view with minimal ad details\n * Returns leads grouped for easy rendering in Kanban columns\n */\nexport async function getPipelineLeads() {\n  const dbClient = await createDrizzleSupabaseClient();\n\n  const pipelineLeads = await dbClient.rls(async (tx) => {\n    const rawLeads = await tx.query.leads.findMany({\n      orderBy: (table, { asc }) => [asc(table.stage), asc(table.position)],\n      with: {\n        ad: {\n          columns: {\n            id: true,\n            title: true,\n            price: true,\n            picture: true,\n            phoneNumber: true,\n            isWhatsappPhone: true,\n          },\n          with: {\n            location: {\n              columns: {\n                name: true,\n              },\n            },\n          },\n        },\n      },\n    });\n\n    // Transform to match KanbanView expected structure\n    return rawLeads.map((lead) => ({\n      id: lead.id,\n      stage: lead.stage,\n      position: lead.position,\n      ad: {\n        title: lead.ad.title,\n        price: lead.ad.price,\n        picture: lead.ad.picture,\n        phoneNumber: lead.ad.phoneNumber,\n        isWhatsappPhone: lead.ad.isWhatsappPhone,\n        zipcode: {\n          name: lead.ad.location.name,\n        },\n      },\n    }));\n  });\n\n  return pipelineLeads;\n}\n\nexport type TPipelineLead = Awaited<\n  ReturnType<typeof getPipelineLeads>\n>[number];\n","/**\n * Worker API Client\n *\n * HTTP client for communicating with the worker service.\n *\n * The worker handles:\n * - WhatsApp messaging (via Baileys)\n * - SMS messaging\n * - Ringless voice messages\n * - Hunt execution (automated prospect outreach)\n *\n * Configuration:\n * - WORKER_API_URL: Worker service URL (e.g., \"https://worker.railway.app\" or \"http://localhost:3001\")\n * - WORKER_API_SECRET: Bearer token for authentication\n *\n * Usage:\n * - Import functions from this file in server actions or server components\n * - Never use in client components (exposes API secret)\n *\n * Error Handling:\n * - All functions return { success: false, error: TErrorCode } on failure\n * - Use getErrorMessage(error) from error-messages.utils.ts to display user-friendly messages\n * - User-actionable errors (MISSING_REQUIRED_FIELDS, etc.) show specific messages\n * - System errors (queue failures, etc.) show generic \"Réessaie\" message\n */\n\nimport {\n  EGeneralErrorCode,\n  TErrorCode,\n  WORKER_ROUTES,\n} from \"@auto-prospect/shared\";\n\nconst WORKER_URL = process.env.WORKER_API_URL;\nconst WORKER_SECRET = process.env.WORKER_API_SECRET;\n\ntype TWorkerSuccess<T> = { success: true } & T;\ntype TWorkerError = { success: false; error: TErrorCode };\ntype TWorkerResult<T> = TWorkerSuccess<T> | TWorkerError;\n\n/**\n * Internal helper for POST requests to worker API\n * Returns structured error codes instead of throwing\n */\nconst workerPost = async <T>(\n  path: string,\n  body: unknown,\n): Promise<TWorkerResult<T>> => {\n  if (!WORKER_URL || !WORKER_SECRET) {\n    return {\n      success: false,\n      error: EGeneralErrorCode.UNKNOWN_ERROR,\n    };\n  }\n\n  try {\n    const response = await fetch(`${WORKER_URL}${path}`, {\n      method: \"POST\",\n      headers: {\n        \"Content-Type\": \"application/json\",\n        Authorization: `Bearer ${WORKER_SECRET}`,\n      },\n      body: JSON.stringify(body),\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      // Worker returns { error: TErrorCode } on failure\n      return {\n        success: false,\n        error: data.error || EGeneralErrorCode.UNKNOWN_ERROR,\n      };\n    }\n\n    // Worker returns { success: true, ...data } on success\n    return data;\n  } catch {\n    // Network errors, JSON parse errors, etc.\n    return {\n      success: false,\n      error: EGeneralErrorCode.UNKNOWN_ERROR,\n    };\n  }\n};\n\n/**\n * Internal helper for GET requests to worker API\n * Returns structured error codes instead of throwing\n */\nconst workerGet = async <T>(path: string): Promise<TWorkerResult<T>> => {\n  if (!WORKER_URL || !WORKER_SECRET) {\n    return {\n      success: false,\n      error: EGeneralErrorCode.UNKNOWN_ERROR,\n    };\n  }\n\n  try {\n    const response = await fetch(`${WORKER_URL}${path}`, {\n      method: \"GET\",\n      headers: {\n        Authorization: `Bearer ${WORKER_SECRET}`,\n      },\n    });\n\n    const data = await response.json();\n\n    if (!response.ok) {\n      // Worker returns { error: TErrorCode } on failure\n      return {\n        success: false,\n        error: data.error || EGeneralErrorCode.UNKNOWN_ERROR,\n      };\n    }\n\n    // Worker returns { success: true, ...data } on success\n    return data;\n  } catch {\n    // Network errors, JSON parse errors, etc.\n    return {\n      success: false,\n      error: EGeneralErrorCode.UNKNOWN_ERROR,\n    };\n  }\n};\n\n// ============================================================================\n// WHATSAPP API\n// ============================================================================\n\n/**\n * Sends a WhatsApp text message\n *\n * @param data.recipientPhone - Phone in international format (e.g., \"+33612345678\")\n * @param data.senderPhone - Your WhatsApp Business account phone\n * @param data.message - Text content to send\n * @returns { success: true, jobId: string } | { success: false, error: TErrorCode }\n *\n * @example\n * const result = await sendWhatsAppText({ ... });\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Job ID:', result.jobId);\n */\nexport const sendWhatsAppText = (data: {\n  recipientPhone: string;\n  senderPhone: string;\n  message: string;\n}): Promise<TWorkerResult<{ jobId: string }>> =>\n  workerPost(WORKER_ROUTES.WHATSAPP_TEXT, data);\n\n// ============================================================================\n// PHONE CHANNEL API (SMS + Voice)\n// ============================================================================\n\n/**\n * Sends an SMS text message\n *\n * @param data.recipientPhone - Phone in international format\n * @param data.message - Text content (max 160 chars for single SMS)\n * @returns { success: true, jobId: string } | { success: false, error: TErrorCode }\n *\n * @example\n * const result = await sendSms({ ... });\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Job ID:', result.jobId);\n */\nexport const sendSms = (data: {\n  recipientPhone: string;\n  message: string;\n}): Promise<TWorkerResult<{ jobId: string }>> =>\n  workerPost(WORKER_ROUTES.PHONE_SMS, data);\n\n/**\n * Sends a ringless voice message (delivered to voicemail without ringing)\n *\n * @param data.recipientPhone - Phone in international format\n * @param data.message - Text to be converted to speech (TTS)\n * @param data.audioUrl - Optional: URL to pre-recorded audio file (alternative to TTS)\n * @returns { success: true, jobId: string } | { success: false, error: TErrorCode }\n *\n * @example\n * const result = await sendRinglessVoice({ ... });\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Job ID:', result.jobId);\n */\nexport const sendRinglessVoice = (data: {\n  recipientPhone: string;\n  message?: string;\n  audioUrl?: string;\n}): Promise<TWorkerResult<{ jobId: string }>> =>\n  workerPost(WORKER_ROUTES.PHONE_RINGLESS_VOICE, data);\n\n// ============================================================================\n// HUNT API (Automated Prospect Outreach)\n// ============================================================================\n\n/**\n * Executes a hunt by sending messages to multiple prospects\n *\n * This is the main entry point for automated prospect hunting.\n * Called by runDailyHunts service after allocating ads to channels.\n *\n * @param data.huntId - Hunt configuration ID\n * @param data.accountId - User's account ID\n * @param data.contacts - Array of contacts to reach out to\n * @returns { success: true, jobId: string, contactCount: number } | { success: false, error: TErrorCode }\n *\n * @example\n * const result = await executeHunt({\n *   huntId: \"hunt_123\",\n *   accountId: \"acc_456\",\n *   contacts: [\n *     {\n *       adId: \"ad_789\",\n *       recipientPhone: \"+33612345678\",\n *       channel: \"whatsapp_text\",\n *       message: \"Bonjour...\",\n *       senderPhone: \"+33601020304\"\n *     }\n *   ]\n * });\n *\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n *\n * console.log(`Hunt started: ${result.jobId}, ${result.contactCount} contacts`);\n */\nexport const executeHunt = (data: {\n  huntId: string;\n  accountId: string;\n  contacts: Array<{\n    adId: string;\n    recipientPhone: string;\n    channel: \"whatsapp_text\" | \"sms\" | \"ringless_voice\";\n    message: string;\n    senderPhone?: string; // Required for WhatsApp\n    audioUrl?: string; // Optional for ringless voice\n  }>;\n}): Promise<TWorkerResult<{ jobId: string; contactCount: number }>> =>\n  workerPost(WORKER_ROUTES.HUNT_EXECUTE, data);\n\n/**\n * Gets the status of a hunt execution\n *\n * @param jobId - The BullMQ job ID returned by executeHunt\n * @returns Promise with job status, progress, and results\n *\n * @example\n * const result = await getHuntStatus('job-123');\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Status:', result.state, 'Progress:', result.progress);\n */\nexport const getHuntStatus = async (\n  jobId: string,\n): Promise<\n  TWorkerResult<{\n    state: string;\n    progress: number;\n    data: unknown;\n    error?: string;\n  }>\n> => {\n  return workerGet(`${WORKER_ROUTES.HUNT_STATUS}/${jobId}`);\n};\n\n// ============================================================================\n// JOB MONITORING API\n// ============================================================================\n\n/**\n * Gets the status of any job in any queue\n *\n * @param queue - Queue name (\"whatsapp\", \"sms\", \"voice\", \"hunt\")\n * @param jobId - Job ID\n * @returns Promise with job details (state, progress, data, errors)\n *\n * @example\n * const result = await getJobStatus('whatsapp', 'job-123');\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Job state:', result.state);\n */\nexport const getJobStatus = async (\n  queue: string,\n  jobId: string,\n): Promise<\n  TWorkerResult<{\n    state: string;\n    progress: number;\n    data: unknown;\n    error?: string;\n  }>\n> => {\n  return workerGet(`${WORKER_ROUTES.JOB_STATUS}/${queue}/${jobId}`);\n};\n\n/**\n * Gets statistics for all queues\n *\n * Useful for dashboard monitoring.\n *\n * @returns Promise with array of queue stats (waiting, active, completed, failed counts)\n *\n * @example\n * const result = await getQueuesStats();\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Queues:', result.stats);\n */\nexport const getQueuesStats = async (): Promise<\n  TWorkerResult<{\n    stats: Array<{\n      queue: string;\n      waiting: number;\n      active: number;\n      completed: number;\n      failed: number;\n    }>;\n  }>\n> => {\n  return workerGet(WORKER_ROUTES.QUEUE_STATS_ALL);\n};\n\n/**\n * Gets statistics for a specific queue\n *\n * @param queue - Queue name (\"whatsapp\", \"sms\", \"voice\", \"hunt\")\n * @returns Promise with queue stats\n *\n * @example\n * const result = await getQueueStats('whatsapp');\n * if (!result.success) {\n *   toast.error(getErrorMessage(result.error));\n *   return;\n * }\n * console.log('Queue stats:', result.waiting, result.active);\n */\nexport const getQueueStats = async (\n  queue: string,\n): Promise<\n  TWorkerResult<{\n    waiting: number;\n    active: number;\n    completed: number;\n    failed: number;\n  }>\n> => {\n  return workerGet(`${WORKER_ROUTES.QUEUE_STATS}/${queue}/stats`);\n};\n","\"use server\";\n\nimport { CACHE_TAGS } from \"@/lib/cache.config\";\nimport { createDrizzleSupabaseClient } from \"@/lib/db\";\nimport { formatZodError } from \"@/lib/validation\";\nimport { sendSms } from \"@/lib/worker-client\";\nimport { getUserAccount } from \"@/services/account.service\";\nimport {\n  getDefaultWhatsAppTemplate as getDefaultWhatsAppTemplateService,\n  logWhatsAppMessage as logWhatsAppMessageService,\n  updateAccountTemplatesCache,\n} from \"@/services/message.service\";\nimport { encryptCredentials } from \"@/utils/crypto.utils\";\nimport { textTemplateSchema, voiceTemplateSchema } from \"@/validation-schemas\";\nimport {\n  saveSmsApiKeySchema,\n  sendSmsSchema,\n  TSaveSmsApiKeySchema,\n  TSendSmsSchema,\n} from \"@/validation-schemas/settings.validation\";\nimport type { BinaryOperator, TANDperator } from \"@auto-prospect/db\";\nimport { accounts, and, eq, messageTemplates } from \"@auto-prospect/db\";\nimport {\n  EGeneralErrorCode,\n  ESmsErrorCode,\n  TErrorCode,\n} from \"@auto-prospect/shared/src/config/error-codes\";\nimport {\n  EContactChannel,\n  TContactChannel,\n} from \"@auto-prospect/shared/src/config/message.config\";\nimport { updateTag } from \"next/cache\";\nimport { z } from \"zod\";\n\n/**\n * Generic template creation function\n * Handles both text and voice templates with type-safe validation\n */\nasync function createTemplate<\n  T extends typeof textTemplateSchema | typeof voiceTemplateSchema,\n>(data: unknown, schema: T, channel: TContactChannel) {\n  // Validate with Zod\n  const parseResult = schema.safeParse(data);\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const validatedData = parseResult.data as T extends typeof textTemplateSchema\n    ? z.infer<typeof textTemplateSchema>\n    : z.infer<typeof voiceTemplateSchema>;\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const account = await getUserAccount(dbClient, {\n      columnsToKeep: { id: true },\n    });\n\n    const accountId = account.id;\n\n    // Determine the actual channel from validated data\n    const actualChannel =\n      \"channel\" in validatedData ? validatedData.channel : channel;\n\n    // If setting as default, unset other defaults for this channel\n    if (validatedData.isDefault) {\n      await dbClient.rls((tx) =>\n        tx\n          .update(messageTemplates)\n          .set({ isDefault: false })\n          .where(\n            and(\n              eq(messageTemplates.accountId, accountId),\n              eq(messageTemplates.channel, actualChannel as TContactChannel),\n            ),\n          ),\n      );\n    }\n\n    let templateValues = {\n      accountId,\n      name: validatedData.name,\n      channel: validatedData.channel as TContactChannel,\n      isDefault: validatedData.isDefault || false,\n      audioUrl: \"\",\n      audioDuration: 0,\n      content: \"\",\n    };\n\n    // Build template values based on type\n    templateValues =\n      channel === EContactChannel.RINGLESS_VOICE\n        ? {\n            ...templateValues,\n            audioUrl: (validatedData as z.infer<typeof voiceTemplateSchema>)\n              .audioUrl,\n            audioDuration: (\n              validatedData as z.infer<typeof voiceTemplateSchema>\n            ).audioDuration,\n          }\n        : {\n            ...templateValues,\n            content: (validatedData as z.infer<typeof textTemplateSchema>)\n              .content,\n          };\n\n    // Create template\n    const [template] = await dbClient.rls(async (tx) => {\n      return tx.insert(messageTemplates).values(templateValues).returning();\n    });\n\n    updateTag(CACHE_TAGS.templatesByAccount(accountId));\n\n    return { success: true, template };\n  } catch {\n    throw new Error(\"Failed to create template\");\n  }\n}\n\n/**\n * Create a new text template\n */\nexport async function createTextTemplate(data: unknown) {\n  return createTemplate(data, textTemplateSchema, EContactChannel.SMS);\n}\n\n/**\n * Create a new voice template\n */\nexport async function createVoiceTemplate(data: unknown) {\n  return createTemplate(\n    data,\n    voiceTemplateSchema,\n    EContactChannel.RINGLESS_VOICE,\n  );\n}\n\n/**\n * Delete a template\n */\nexport async function deleteTemplate(templateId: string) {\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    await dbClient.rls(async (tx) => {\n      await tx\n        .delete(messageTemplates)\n        .where(eq(messageTemplates.id, templateId));\n    });\n\n    await updateAccountTemplatesCache(dbClient);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting template:\", error);\n    throw new Error(\"Failed to delete template\");\n  }\n}\n\n/**\n * Update a template\n */\nexport async function updateTemplate(\n  templateId: string,\n  data: {\n    name?: string;\n    content?: string;\n    isDefault?: boolean;\n  },\n) {\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const updates: {\n      name?: string;\n      content?: string;\n      isDefault?: boolean;\n      updatedAt: Date;\n    } = {\n      updatedAt: new Date(),\n    };\n\n    if (data.name !== undefined) updates.name = data.name.trim();\n    if (data.content !== undefined) updates.content = data.content.trim();\n    if (data.isDefault !== undefined) {\n      updates.isDefault = data.isDefault;\n\n      // If setting as default, get template to unset others of same type/channel\n      if (data.isDefault) {\n        const template = await dbClient.rls(async (tx) => {\n          return tx.query.messageTemplates.findFirst({\n            where: eq(messageTemplates.id, templateId),\n          });\n        });\n\n        if (template) {\n          await dbClient.rls(async (tx) => {\n            const conditions = [\n              (\n                table: typeof messageTemplates,\n                { eq, and }: { eq: BinaryOperator; and: TANDperator },\n              ) =>\n                and(\n                  eq(table.accountId, template.accountId),\n                  eq(table.channel, template.channel),\n                ),\n            ];\n\n            if (template.channel) {\n              conditions.push(\n                (\n                  table: typeof messageTemplates,\n                  { eq }: { eq: BinaryOperator },\n                ) => eq(table.channel, template.channel!),\n              );\n            }\n\n            await tx\n              .update(messageTemplates)\n              .set({ isDefault: false })\n              .where(\n                and(...conditions.map((c) => c(messageTemplates, { eq, and }))),\n              );\n          });\n        }\n      }\n    }\n\n    await dbClient.rls(async (tx) => {\n      await tx\n        .update(messageTemplates)\n        .set(updates)\n        .where(eq(messageTemplates.id, templateId));\n    });\n\n    await updateAccountTemplatesCache(dbClient);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating template:\", error);\n    throw new Error(\"Failed to update template\");\n  }\n}\n\n/**\n * Get the default WhatsApp template for a lead's account\n * Server action wrapper for client-side calls\n */\nexport async function getDefaultWhatsAppTemplate(leadId: string) {\n  return getDefaultWhatsAppTemplateService(leadId);\n}\n\n/**\n * Log a WhatsApp message attempt\n * Server action wrapper for client-side calls\n */\nexport async function logWhatsAppMessage(\n  leadId: string,\n  renderedMessage: string,\n  templateId?: string,\n) {\n  return logWhatsAppMessageService(leadId, renderedMessage, templateId);\n}\n\ntype SendSmsResult = {\n  success: boolean;\n  errorCode?: TErrorCode;\n  data?: Record<string, unknown>;\n};\n\n/**\n * Sends an SMS message via SMS Mobile API using the user's own API key\n * Validates input, fetches user's API key from their account, and calls the messaging service\n */\nexport async function sendSmsAction(\n  data: TSendSmsSchema,\n): Promise<SendSmsResult> {\n  // Validate data\n  const validation = sendSmsSchema.safeParse(data);\n  if (!validation.success) {\n    return {\n      success: false,\n      errorCode: EGeneralErrorCode.VALIDATION_FAILED,\n    };\n  }\n\n  const { to, message } = validation.data;\n\n  try {\n    // Fetch user's account to get their SMS API key\n    const dbClient = await createDrizzleSupabaseClient();\n\n    // Use admin client to bypass RLS (server action is already authenticated)\n    const account = await getUserAccount(dbClient, {\n      columnsToKeep: { smsApiKey: true },\n    });\n\n    if (!account.smsApiKey) {\n      return {\n        success: false,\n        errorCode: ESmsErrorCode.API_KEY_REQUIRED,\n      };\n    }\n\n    // Call worker endpoint\n    const result = await sendSms({\n      recipientPhone: to,\n      message,\n    });\n\n    if (!result.success) {\n      return { success: false, errorCode: result.error };\n    }\n\n    return { success: true, data: { jobId: result.jobId } };\n  } catch {\n    return {\n      success: false,\n      errorCode: ESmsErrorCode.MESSAGE_SEND_FAILED,\n    };\n  }\n}\n\ntype SaveSmsApiKeyResult = {\n  success: boolean;\n  errorCode?: TErrorCode;\n};\n\n/**\n * Saves the user's SMS API key (encrypted) to their account\n */\nexport async function saveSmsApiKeyAction(\n  data: TSaveSmsApiKeySchema,\n): Promise<SaveSmsApiKeyResult> {\n  // Validate data\n  const validation = saveSmsApiKeySchema.safeParse(data);\n  if (!validation.success) {\n    return {\n      success: false,\n      errorCode: EGeneralErrorCode.VALIDATION_FAILED,\n    };\n  }\n\n  const { apiKey } = validation.data;\n\n  try {\n    const dbClient = await createDrizzleSupabaseClient();\n\n    const account = await getUserAccount(dbClient, {\n      columnsToKeep: { id: true, smsApiKey: true },\n    });\n\n    // Encrypt the API key before storing\n    const encryptionKey = process.env.SMS_API_KEY_ENCRYPTION_KEY;\n    if (!encryptionKey) {\n      return {\n        success: false,\n        errorCode: ESmsErrorCode.ENCRYPTION_KEY_MISSING,\n      };\n    }\n\n    const encryptedApiKey = encryptCredentials(apiKey, encryptionKey);\n\n    // Update the account with the encrypted API key\n    // Use admin client to bypass RLS (server action is already authenticated)\n    const result = await dbClient.rls((tx) =>\n      tx\n        .update(accounts)\n        .set({ smsApiKey: encryptedApiKey })\n        .where(eq(accounts.id, account.id))\n        .returning({ id: accounts.id }),\n    );\n\n    if (!result || result.length === 0) {\n      return {\n        success: false,\n        errorCode: ESmsErrorCode.ACCOUNT_NOT_FOUND,\n      };\n    }\n\n    return { success: true };\n  } catch {\n    return {\n      success: false,\n      errorCode: ESmsErrorCode.API_KEY_SAVE_FAILED,\n    };\n  }\n}\n","/**\n * @deprecated Use crypto utilities from @auto-prospect/shared instead\n */\nexport { encryptCredentials, decryptCredentials, generateEncryptionKey } from \"@auto-prospect/shared\";\n","\"use server\";\n\nimport { pages } from \"@/config/routes\";\nimport { createDrizzleSupabaseClient } from \"@/lib/db\";\nimport { formatZodError } from \"@/lib/validation\";\nimport {\n  getLeadActivities,\n  getLeadAssociatedTeamMembers,\n  getLeadDetails,\n  getLeadMessages,\n  getPipelineLeads,\n} from \"@/services/lead.service\";\nimport { leadNoteSchema, leadReminderSchema } from \"@/validation-schemas\";\nimport {\n  eq,\n  inArray,\n  leadNotes,\n  leadReminders,\n  leads,\n} from \"@auto-prospect/db\";\nimport { TLeadStage } from \"@auto-prospect/shared/src/config/lead.config\";\nimport { revalidatePath } from \"next/cache\";\nimport { createClient } from \"../../../../packages/db/src/supabase/server\";\n\n/**\n * Fetches complete lead details with all relations\n * Server action wrapper for SWR client-side fetching\n */\nexport async function fetchLeadDetails(leadId: string) {\n  return getLeadDetails(leadId);\n}\n\n/**\n * Fetches all members of the lead's account for assignment dropdown\n * Server action wrapper for SWR client-side fetching\n */\nexport async function fetchLeadTeamMembers(leadId: string) {\n  return getLeadAssociatedTeamMembers(leadId);\n}\n\n/**\n * Fetches message history for a lead\n * Server action wrapper for SWR client-side fetching\n */\nexport async function fetchLeadMessages(leadId: string) {\n  return getLeadMessages(leadId);\n}\n\n/**\n * Fetches activity timeline for a lead\n * Server action wrapper for SWR client-side fetching\n */\nexport async function fetchLeadActivities(leadId: string) {\n  return getLeadActivities(leadId);\n}\n\n/**\n * Fetches all leads for the pipeline/kanban view\n * Server action wrapper for SWR client-side fetching\n */\nexport async function fetchPipelineLeads() {\n  return getPipelineLeads();\n}\n\n/**\n * Updates a lead's stage and logs the activity\n * Used when dragging leads between Kanban columns\n */\nexport async function updateLeadStage(leadId: string, newStage: TLeadStage) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    // RLS query wrapper - enforces account access\n    await dbClient.rls(async (tx) => {\n      // Update lead stage and updatedAt timestamp\n      await tx\n        .update(leads)\n        .set({\n          stage: newStage,\n          updatedAt: new Date(),\n        })\n        .where(eq(leads.id, leadId));\n\n      // Log activity as a note\n      await tx.insert(leadNotes).values({\n        leadId,\n        content: `Stage changé vers: ${newStage}`,\n      });\n    });\n\n    revalidatePath(pages.leads.list);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating lead stage:\", error);\n    throw new Error(\"Failed to update lead stage\");\n  }\n}\n\n/**\n * Updates the position of a lead within its stage (for drag reordering)\n */\nexport async function updateLeadPosition(\n  leadId: string,\n  newPosition: number,\n  newStage?: TLeadStage,\n) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const updateData: {\n      position: number;\n      updatedAt: Date;\n      stage?: TLeadStage;\n    } = {\n      position: newPosition,\n      updatedAt: new Date(),\n    };\n\n    if (newStage) {\n      updateData.stage = newStage;\n    }\n\n    await dbClient.rls(async (tx) => {\n      await tx.update(leads).set(updateData).where(eq(leads.id, leadId));\n    });\n\n    revalidatePath(pages.leads.list);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error updating lead position:\", error);\n    throw new Error(\"Failed to update lead position\");\n  }\n}\n\n/**\n * Bulk update multiple leads (stage, assignment, etc.)\n * Used for bulk actions in list view\n */\nexport async function bulkUpdateLeads(\n  leadIds: string[],\n  updates: {\n    stage?: TLeadStage;\n    assignedToId?: string | null;\n  },\n) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  if (leadIds.length === 0) {\n    return { success: true, count: 0 };\n  }\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    // Update all leads\n    const updateData: {\n      updatedAt: Date;\n      stage?: TLeadStage;\n      assignedToId?: string | null;\n    } = {\n      updatedAt: new Date(),\n    };\n\n    if (updates.stage !== undefined) {\n      updateData.stage = updates.stage;\n    }\n    if (updates.assignedToId !== undefined) {\n      updateData.assignedToId = updates.assignedToId;\n    }\n\n    await dbClient.rls(async (tx) => {\n      await tx.update(leads).set(updateData).where(inArray(leads.id, leadIds));\n\n      // Log bulk action as notes for each lead\n      const noteContent: string[] = [];\n      if (updates.stage) noteContent.push(`Stage: ${updates.stage}`);\n      if (updates.assignedToId !== undefined)\n        noteContent.push(`Assigné à: ${updates.assignedToId || \"Non assigné\"}`);\n\n      if (noteContent.length > 0) {\n        await tx.insert(leadNotes).values(\n          leadIds.map((leadId) => ({\n            leadId,\n            content: `Action groupée - ${noteContent.join(\", \")}`,\n          })),\n        );\n      }\n    });\n\n    revalidatePath(pages.leads.list);\n\n    return { success: true, count: leadIds.length };\n  } catch (error) {\n    console.error(\"Error bulk updating leads:\", error);\n    throw new Error(\"Failed to bulk update leads\");\n  }\n}\n\n/**\n * Assign a lead to a user\n */\nexport async function assignLead(leadId: string, userId: string | null) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    await dbClient.rls(async (tx) => {\n      await tx\n        .update(leads)\n        .set({\n          assignedToId: userId,\n          updatedAt: new Date(),\n        })\n        .where(eq(leads.id, leadId));\n\n      // Log assignment\n      await tx.insert(leadNotes).values({\n        leadId,\n        content: userId ? `Lead assigné à un utilisateur` : `Lead non assigné`,\n      });\n    });\n\n    revalidatePath(pages.leads.list);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error assigning lead:\", error);\n    throw new Error(\"Failed to assign lead\");\n  }\n}\n\n/**\n * Add a note to a lead\n */\nexport async function addLeadNote(leadId: string, content: unknown) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  // Validate content with Zod\n  const parseResult = leadNoteSchema.safeParse({ content });\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const validatedContent = parseResult.data.content;\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const note = await dbClient.rls(async (tx) => {\n      const [newNote] = await tx\n        .insert(leadNotes)\n        .values({\n          leadId,\n          content: validatedContent.trim(),\n        })\n        .returning();\n\n      return newNote;\n    });\n\n    revalidatePath(pages.leads.detail(leadId));\n\n    return { success: true, note };\n  } catch (error) {\n    console.error(\"Error adding lead note:\", error);\n    throw new Error(\"Failed to add note\");\n  }\n}\n\n/**\n * Add a reminder for a lead\n */\nexport async function addLeadReminder(\n  leadId: string,\n  dueAt: unknown,\n  note?: unknown,\n) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  // Validate reminder data with Zod\n  const parseResult = leadReminderSchema.safeParse({ dueAt, note });\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const { dueAt: validatedDueAt, note: validatedNote } = parseResult.data;\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    const reminder = await dbClient.rls(async (tx) => {\n      const [newReminder] = await tx\n        .insert(leadReminders)\n        .values({\n          leadId,\n          dueAt: validatedDueAt,\n          note: validatedNote?.trim() || null,\n        })\n        .returning();\n\n      return newReminder;\n    });\n\n    revalidatePath(pages.leads.detail(leadId));\n\n    return { success: true, reminder };\n  } catch (error) {\n    console.error(\"Error adding lead reminder:\", error);\n    throw new Error(\"Failed to add reminder\");\n  }\n}\n\n/**\n * Delete a reminder\n */\nexport async function deleteLeadReminder(reminderId: string) {\n  const supabase = await createClient();\n  const {\n    data: { session },\n  } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error(\"Unauthorized\");\n  }\n\n  const dbClient = await createDrizzleSupabaseClient();\n\n  try {\n    await dbClient.rls(async (tx) => {\n      await tx.delete(leadReminders).where(eq(leadReminders.id, reminderId));\n    });\n\n    revalidatePath(pages.leads.list);\n\n    return { success: true };\n  } catch (error) {\n    console.error(\"Error deleting reminder:\", error);\n    throw new Error(\"Failed to delete reminder\");\n  }\n}\n","export {fetchPipelineLeads as '0005bc12ba53c44da372d8a38ac6ef55306543beb5'} from 'ACTIONS_MODULE0'\nexport {updateLeadStage as '601dde30ce0c9cae3cb7403002e4122bd509201b08'} from 'ACTIONS_MODULE0'\nexport {addLeadNote as '60a072972f4910e494169b648c8535160e0004e907'} from 'ACTIONS_MODULE0'\nexport {addLeadReminder as '7081dde443da713cd9b26d85ee004ea263c5708e04'} from 'ACTIONS_MODULE0'\nexport {assignLead as '60b34ebf9bf068fea6a73474b91f2d5419eadf343e'} from 'ACTIONS_MODULE0'\nexport {deleteLeadReminder as '4059db70c15d9497d084adb458bf761869623a7a94'} from 'ACTIONS_MODULE0'\nexport {fetchLeadDetails as '40abed2c5b10b09605427ad68c1e5d1af19bbd1f78'} from 'ACTIONS_MODULE0'\nexport {fetchLeadTeamMembers as '40da113c71834aa7676191e8f90039431d5c90d234'} from 'ACTIONS_MODULE0'\nexport {getDefaultWhatsAppTemplate as '401540e838a62e09eb1eeaba6e998d062d354b5304'} from 'ACTIONS_MODULE1'\nexport {logWhatsAppMessage as '7013b2cfceb896ab0561b14d5adfd1fb89f374894b'} from 'ACTIONS_MODULE1'\n"],"names":[],"mappings":"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"}