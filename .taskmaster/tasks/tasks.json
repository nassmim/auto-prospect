{
  "master": {
    "tasks": [
      {
        "id": "1",
        "title": "Create Organization and Team Schema with RLS",
        "description": "Define Drizzle schemas for organizations, memberships, and team roles to support multi-tenant team management. This builds on the existing accounts table by adding organization-level grouping.",
        "details": "Create schemas in `src/schema/organization.schema.ts`:\n\n1. **organizations table:**\n   - `id`: uuid, primary key, default random\n   - `name`: varchar(255), required\n   - `ownerId`: uuid, FK to accounts.id, on delete cascade\n   - `settings`: jsonb (store toggles: allowReassignment, restrictVisibility, dailyReset, ignorePhonesVisible)\n   - `createdAt`: timestamp, default now\n   - RLS policies: owner can update/delete, members can read\n\n2. **organization_members table:**\n   - `id`: uuid, primary key\n   - `organizationId`: uuid, FK to organizations.id\n   - `accountId`: uuid, FK to accounts.id\n   - `role`: varchar enum ('owner', 'admin', 'user')\n   - `invitedAt`: timestamp\n   - `joinedAt`: timestamp nullable\n   - Unique constraint on (organizationId, accountId)\n   - RLS: org members can read, owner/admin can write\n\n3. **organization_invitations table:**\n   - `id`: uuid, primary key\n   - `organizationId`: uuid, FK\n   - `email`: varchar(320)\n   - `role`: varchar\n   - `token`: varchar(64) unique\n   - `expiresAt`: timestamp\n   - RLS: org admins can manage\n\nRemember to add explicit grants in migration SQL for authenticated and service_role as per project patterns in 0002_magenta_multiple_man.sql.",
        "testStrategy": "1. Generate migration with `pnpm db:generate` and verify SQL output contains RLS policies and grants. 2. After migration applied (by human), write integration tests that verify: owner can CRUD organization, member can only read, non-member cannot access. 3. Test invitation flow creates valid token.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-21T14:39:28.276Z"
      },
      {
        "id": "2",
        "title": "Create Hunt Schema for Saved Searches",
        "description": "Define the Hunt entity that represents a saved search configuration for automated scraping. Hunts store search criteria (URL or filters) and outreach settings.",
        "details": "Create `src/schema/hunt.schema.ts`:\n\n1. **hunts table:**\n   - `id`: uuid, primary key, default random\n   - `organizationId`: uuid, FK to organizations.id, required\n   - `name`: varchar(255), required\n   - `status`: varchar enum ('active', 'paused'), default 'active'\n   - `searchType`: varchar enum ('url', 'builder')\n   - `searchUrl`: text nullable (for URL paste mode)\n   - `searchFilters`: jsonb nullable (for builder mode: { platform, priceMin, priceMax, mileageMin, mileageMax, brands[], location, radius })\n   - `autoRefresh`: boolean, default true\n   - `outreachSettings`: jsonb ({ leboncoin: boolean, whatsapp: boolean, sms: boolean })\n   - `templateIds`: jsonb ({ leboncoin: uuid|null, whatsapp: uuid|null, sms: uuid|null })\n   - `lastScanAt`: timestamp nullable\n   - `createdAt`: timestamp, default now\n   - `createdById`: uuid, FK to accounts.id\n   - Index on (organizationId, status) for active hunt queries\n   - RLS: org members can CRUD\n\n2. Add FK constraints with proper cascade behavior\n3. Add explicit grants for authenticated, service_role",
        "testStrategy": "1. Verify migration generates correct SQL with indexes and RLS. 2. Test that creating a hunt with URL type stores URL correctly. 3. Test builder filters serialization/deserialization. 4. Verify org member isolation via RLS.",
        "priority": "high",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-21T15:12:55.547Z"
      },
      {
        "id": "3",
        "title": "Extend Ads Schema into Leads with Pipeline Stages",
        "description": "Extend the existing ads table with lead-specific fields (stage, assignment, source hunt) or create a separate leads table that references ads. This enables the Kanban pipeline functionality.",
        "details": "Create `src/schema/lead.schema.ts` (separate from raw ads for clean separation):\n\n1. **leads table:**\n   - `id`: uuid, primary key, default random\n   - `organizationId`: uuid, FK to organizations.id\n   - `huntId`: uuid, FK to hunts.id (source hunt)\n   - `adId`: uuid, FK to ads.id (the scraped listing data)\n   - `stage`: varchar enum ('nouveau', 'contacte', 'relance', 'negociation', 'gagne', 'perdu'), default 'nouveau'\n   - `assignedToId`: uuid, FK to accounts.id, nullable\n   - `position`: integer (for ordering within stage)\n   - `createdAt`: timestamp, default now\n   - `updatedAt`: timestamp, default now\n   - Unique constraint on (organizationId, adId) - prevent duplicate leads\n   - Index on (organizationId, stage) for Kanban queries\n   - Index on (organizationId, assignedToId) for user filtering\n   - RLS: org members can access, with visibility restriction option\n\n2. **lead_notes table:**\n   - `id`: uuid, primary key\n   - `leadId`: uuid, FK to leads.id, on delete cascade\n   - `content`: text\n   - `createdById`: uuid, FK to accounts.id\n   - `createdAt`: timestamp\n   - RLS: org members can CRUD\n\n3. **lead_reminders table:**\n   - `id`: uuid, primary key\n   - `leadId`: uuid, FK to leads.id, on delete cascade\n   - `dueAt`: timestamp\n   - `note`: text nullable\n   - `completed`: boolean, default false\n   - `createdById`: uuid, FK to accounts.id\n   - RLS: org members can CRUD",
        "testStrategy": "1. Create lead from existing ad, verify FK relationship. 2. Test stage transitions update `updatedAt`. 3. Test duplicate prevention (same ad + org). 4. Verify Kanban query performance with explain analyze on stage index.",
        "priority": "high",
        "dependencies": [
          "1",
          "2"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create leads table schema with stage enum and FK relationships",
            "description": "Define the leads pgTable in src/schema/lead.schema.ts with all required fields: id, organizationId, huntId, adId, stage enum, assignedToId, position, timestamps, and foreign key relationships to organizations, hunts, ads, and accounts tables.",
            "dependencies": [],
            "details": "Create `src/schema/lead.schema.ts` with:\n1. Export lead stage enum type: `leadStages = ['nouveau', 'contacte', 'relance', 'negociation', 'gagne', 'perdu'] as const`\n2. Define `leads` pgTable with columns:\n   - `id`: uuid().primaryKey().notNull().default(sql`gen_random_uuid()`)\n   - `organizationId`: uuid('organization_id').notNull()\n   - `huntId`: uuid('hunt_id').notNull()\n   - `adId`: uuid('ad_id').notNull()\n   - `stage`: varchar({ length: 20 }).notNull().default('nouveau')\n   - `assignedToId`: uuid('assigned_to_id')\n   - `position`: integer().notNull().default(0)\n   - `createdAt`/`updatedAt`: timestamp with timezone, defaults\n3. Add foreign keys using foreignKey() helper with onDelete cascade for org/hunt/ad, set null for assignedTo\n4. Import required dependencies from drizzle-orm/pg-core and reference existing tables from organization.schema, hunt.schema, ad.schema, account.schema",
            "status": "done",
            "testStrategy": "Verify schema compiles with pnpm db:generate, inspect generated migration SQL for correct column types and FK constraints",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:29:06.411Z"
          },
          {
            "id": 2,
            "title": "Add unique constraint and performance indexes to leads table",
            "description": "Add the unique constraint on (organizationId, adId) to prevent duplicate leads, plus composite indexes for Kanban stage queries and user assignment filtering.",
            "dependencies": [
              1
            ],
            "details": "In the leads table third argument (constraints/indexes function), add:\n1. `unique('leads_org_ad_unique').on(table.organizationId, table.adId)` - Prevents same ad being added as lead twice in same org\n2. `index('leads_organization_stage_idx').on(table.organizationId, table.stage)` - Critical for Kanban column queries\n3. `index('leads_organization_assigned_idx').on(table.organizationId, table.assignedToId)` - For filtering leads by team member\n4. `index('leads_hunt_id_idx').on(table.huntId)` - For querying leads by source hunt\n5. Consider partial index for active stages if needed later for performance",
            "status": "done",
            "testStrategy": "Run pnpm db:generate and verify migration includes CREATE UNIQUE INDEX and CREATE INDEX statements with correct column combinations",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:29:11.285Z"
          },
          {
            "id": 3,
            "title": "Implement RLS policies for leads table with org member access",
            "description": "Add Row Level Security policies to leads table ensuring only organization members can access leads, following the existing pattern from hunts table with joined_at verification.",
            "dependencies": [
              1
            ],
            "details": "Add to leads table constraints:\n1. Enable RLS with pgPolicy for 'all' operations to authenticatedRole\n2. Using clause: `sql\\`exists (select 1 from organization_members om where om.organization_id = ${table.organizationId} and om.account_id = ${authUid} and om.joined_at is not null)\\``\n3. WithCheck clause: same subquery for insert/update validation\n4. Import authenticatedRole, authUid from drizzle-orm/supabase\n5. After migration generation, manually add to SQL: `grant select, insert, update, delete on table public.leads to authenticated, service_role;`\n6. Ensure migration includes `ALTER TABLE \"leads\" ENABLE ROW LEVEL SECURITY;`",
            "status": "done",
            "testStrategy": "After migration, test via Supabase client that user in org A cannot see leads from org B, and non-member cannot access any leads",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:29:16.731Z"
          },
          {
            "id": 4,
            "title": "Create lead_notes and lead_reminders tables with cascading FK",
            "description": "Define supporting tables for lead collaboration: lead_notes for text annotations and lead_reminders for follow-up scheduling, both with cascade delete from parent lead.",
            "dependencies": [
              1
            ],
            "details": "In src/schema/lead.schema.ts, add two more pgTables:\n\n**lead_notes:**\n- `id`: uuid().primaryKey().default(sql`gen_random_uuid()`)\n- `leadId`: uuid('lead_id').notNull() with FK to leads.id onDelete cascade\n- `content`: text().notNull()\n- `createdById`: uuid('created_by_id').notNull() with FK to accounts.id\n- `createdAt`: timestamp with default now()\n- RLS: org members can CRUD (join through leads to organization_members)\n\n**lead_reminders:**\n- `id`: uuid().primaryKey().default(sql`gen_random_uuid()`)\n- `leadId`: uuid('lead_id').notNull() with FK to leads.id onDelete cascade\n- `dueAt`: timestamp with timezone, notNull\n- `note`: text()\n- `completed`: boolean().default(false).notNull()\n- `createdById`: uuid('created_by_id').notNull() with FK to accounts.id\n- `createdAt`: timestamp with default now()\n- RLS: org members via leads join, index on (leadId, completed, dueAt)",
            "status": "done",
            "testStrategy": "Create lead, add note and reminder, delete lead and verify cascade deletes notes/reminders. Test completed filter query uses index.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:29:22.062Z"
          },
          {
            "id": 5,
            "title": "Add Drizzle relations and export schema from index",
            "description": "Define Drizzle ORM relations for leads, lead_notes, and lead_reminders tables to enable typed eager loading, then export all new schemas from src/schema/index.ts.",
            "dependencies": [
              1,
              4
            ],
            "details": "1. Add relations in lead.schema.ts:\n```typescript\nexport const leadsRelations = relations(leads, ({ one, many }) => ({\n  organization: one(organizations, { fields: [leads.organizationId], references: [organizations.id] }),\n  hunt: one(hunts, { fields: [leads.huntId], references: [hunts.id] }),\n  ad: one(ads, { fields: [leads.adId], references: [ads.id] }),\n  assignedTo: one(accounts, { fields: [leads.assignedToId], references: [accounts.id] }),\n  notes: many(leadNotes),\n  reminders: many(leadReminders),\n}));\n\nexport const leadNotesRelations = relations(leadNotes, ({ one }) => ({\n  lead: one(leads, { fields: [leadNotes.leadId], references: [leads.id] }),\n  createdBy: one(accounts, { fields: [leadNotes.createdById], references: [accounts.id] }),\n}));\n\nexport const leadRemindersRelations = relations(leadReminders, ...);\n```\n2. Update src/schema/index.ts: add `export * from '@/schema/lead.schema';`\n3. Run pnpm db:generate to produce final migration",
            "status": "done",
            "testStrategy": "After adding relations, write a test query using db.query.leads.findFirst({ with: { notes: true, ad: true } }) to verify typed eager loading works correctly",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:29:43.984Z"
          }
        ],
        "updatedAt": "2026-01-21T15:29:43.984Z"
      },
      {
        "id": "4",
        "title": "Create Message Templates Schema",
        "description": "Define schemas for text and voice message templates with support for dynamic variables. Templates are organization-scoped and can be used for WhatsApp, SMS, and platform messaging.",
        "details": "Create `src/schema/message-template.schema.ts`:\n\n1. **message_templates table:**\n   - `id`: uuid, primary key, default random\n   - `organizationId`: uuid, FK to organizations.id\n   - `name`: varchar(255), required\n   - `type`: varchar enum ('text', 'voice')\n   - `channel`: varchar enum ('whatsapp', 'sms', 'leboncoin') nullable (null for voice)\n   - `content`: text (for text templates, with variable placeholders like {titre_annonce})\n   - `audioUrl`: text nullable (Supabase Storage URL for voice)\n   - `audioDuration`: integer nullable (in seconds, validated 15-55)\n   - `isDefault`: boolean, default false\n   - `createdAt`: timestamp, default now\n   - `updatedAt`: timestamp, default now\n   - `createdById`: uuid, FK to accounts.id\n   - RLS: org members can CRUD\n\n2. **template_variables table (static reference):**\n   - `id`: smallserial, primary key\n   - `key`: varchar(50) unique (e.g., 'titre_annonce', 'ia_titre_annonce')\n   - `label`: varchar(100) (display name in French)\n   - `description`: text\n   - Public read access\n\n3. Seed template_variables with values from PRD:\n   - {titre_annonce} -> Original listing title\n   - {ia_titre_annonce} -> AI-cleaned title\n   - {ia_type_de_bien} -> AI-detected type\n   - {lieu_annonce} -> City/location\n   - {prix_annonce} -> Price",
        "testStrategy": "1. Create text template with variables, verify storage. 2. Test voice template duration validation (reject <15s or >55s). 3. Verify variable substitution logic works with sample lead data. 4. Test org isolation.",
        "priority": "medium",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T16:05:22.190Z"
      },
      {
        "id": "5",
        "title": "Create Messages and Activity Log Schema",
        "description": "Define schemas for tracking sent messages and lead activity history. This supports message history view and activity logging in lead detail.",
        "details": "Create `src/schema/message.schema.ts`:\n\n1. **messages table:**\n   - `id`: uuid, primary key, default random\n   - `leadId`: uuid, FK to leads.id, on delete cascade\n   - `templateId`: uuid, FK to message_templates.id, nullable\n   - `channel`: varchar enum ('whatsapp', 'sms', 'voice', 'leboncoin')\n   - `content`: text (rendered message with variables replaced)\n   - `status`: varchar enum ('pending', 'sent', 'delivered', 'failed', 'read')\n   - `externalId`: varchar nullable (provider message ID for tracking)\n   - `sentAt`: timestamp nullable\n   - `createdAt`: timestamp, default now\n   - `sentById`: uuid, FK to accounts.id\n   - Index on (leadId, createdAt) for message history queries\n   - RLS: org members can CRUD\n\n2. **lead_activities table:**\n   - `id`: uuid, primary key, default random\n   - `leadId`: uuid, FK to leads.id, on delete cascade\n   - `type`: varchar enum ('stage_change', 'message_sent', 'assignment_change', 'note_added', 'reminder_set', 'created')\n   - `metadata`: jsonb (type-specific data: { fromStage, toStage } or { channel, status })\n   - `createdAt`: timestamp, default now\n   - `createdById`: uuid, FK to accounts.id\n   - Index on (leadId, createdAt) for timeline queries\n   - RLS: org members can read\n\n3. Create DB trigger function to auto-log activities on stage changes (optional, can be app-level)",
        "testStrategy": "1. Send message to lead, verify message record created with correct lead association. 2. Change lead stage, verify activity logged. 3. Query message history for lead, verify chronological ordering. 4. Test status transitions.",
        "priority": "medium",
        "dependencies": [
          "3",
          "4"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T16:07:23.949Z"
      },
      {
        "id": "6",
        "title": "Create Credits and Transactions Schema",
        "description": "Define schemas for SMS and voice credit balances with transaction audit logging. Supports the credits purchase and usage tracking system.",
        "details": "Create `src/schema/credits.schema.ts`:\n\n1. **credit_balances table:**\n   - `id`: uuid, primary key, default random\n   - `organizationId`: uuid, FK to organizations.id, unique\n   - `smsCredits`: integer, default 0\n   - `voiceCredits`: integer, default 0\n   - `updatedAt`: timestamp, default now\n   - RLS: org members can read, service_role can update\n\n2. **credit_transactions table:**\n   - `id`: uuid, primary key, default random\n   - `organizationId`: uuid, FK to organizations.id\n   - `type`: varchar enum ('purchase', 'usage', 'refund', 'adjustment')\n   - `creditType`: varchar enum ('sms', 'voice')\n   - `amount`: integer (positive for purchase, negative for usage)\n   - `balanceAfter`: integer\n   - `referenceId`: uuid nullable (message_id for usage, stripe payment_id for purchase)\n   - `metadata`: jsonb nullable (pack details, pricing info)\n   - `createdAt`: timestamp, default now\n   - `createdById`: uuid, FK to accounts.id nullable (null for system)\n   - Index on (organizationId, createdAt) for transaction history\n   - RLS: org members can read, service_role can insert\n\n3. Define credit packs as constants (from PRD):\n   ```typescript\n   export const SMS_PACKS = [\n     { credits: 100, priceEur: 15 },\n     { credits: 500, priceEur: 70 },\n     { credits: 1000, priceEur: 100 },\n     { credits: 5000, priceEur: 400 },\n   ];\n   export const VOICE_PACKS = [\n     { credits: 100, priceEur: 40 },\n     { credits: 500, priceEur: 175 },\n     { credits: 1000, priceEur: 300 },\n     { credits: 5000, priceEur: 1250 },\n   ];\n   ```",
        "testStrategy": "1. Initialize balance for new org, verify defaults to 0. 2. Add credits via purchase transaction, verify balance updated and transaction logged. 3. Deduct credits via usage, verify atomic balance update with transaction. 4. Test insufficient balance handling.",
        "priority": "low",
        "dependencies": [
          "1"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T16:04:39.082Z"
      },
      {
        "id": "7",
        "title": "Build App Shell Layout with Dark Theme and Navigation",
        "description": "Create the main application layout with sidebar navigation, dark theme styling, and responsive design following the Altoscan-inspired aesthetic. This provides the shell for all authenticated pages.",
        "details": "Create layout components in `src/app/(app)/layout.tsx`:\n\n1. **App Layout Structure:**\n   - Protected route group `(app)` with auth middleware check\n   - Sidebar navigation (collapsible on mobile)\n   - Main content area with max-width constraint\n   - Top header with user menu, org switcher\n\n2. **Sidebar Navigation Items:**\n   - Dashboard (Home icon)\n   - Hunts/Recherches (Search icon)\n   - Leads/Pipeline (Kanban icon)\n   - Templates (Message icon)\n   - Settings (Cog icon)\n   - Credits (Coins icon)\n\n3. **Styling (Tailwind CSS 4):**\n   - Dark theme as default (bg-zinc-950, text-zinc-100)\n   - Amber accent color for CTAs (amber-500/600)\n   - Card-based layout with subtle borders (border-zinc-800)\n   - Geist font already configured in root layout\n   - Consistent spacing (p-4, gap-4 patterns)\n\n4. **Files to create:**\n   - `src/app/(app)/layout.tsx` - Main layout\n   - `src/components/layout/sidebar.tsx` - Navigation sidebar\n   - `src/components/layout/header.tsx` - Top header\n   - `src/components/layout/user-menu.tsx` - User dropdown\n   - Update `globals.css` with dark theme CSS variables\n\n5. **Auth Guard:** Check Supabase session in layout, redirect to /login if not authenticated",
        "testStrategy": "1. Verify dark theme renders correctly with Tailwind 4. 2. Test responsive behavior - sidebar collapses on mobile. 3. Verify auth redirect for unauthenticated users. 4. Navigate between all sections, verify active state styling.",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-21T15:09:14.574Z"
      },
      {
        "id": "8",
        "title": "Build Dashboard Page with Stats and Hunt List",
        "description": "Implement the dashboard homepage showing stats cards (new leads today, messages sent), active hunts list, and quick actions. Reference: 01-dashboard-stats-projects.png",
        "details": "Create dashboard in `src/app/(app)/dashboard/page.tsx`:\n\n1. **Stats Cards Row (Server Component queries):**\n   - New leads today: COUNT from leads WHERE createdAt >= today AND organizationId = current\n   - Leads contacted: COUNT from leads WHERE stage = 'contacte'\n   - Messages sent (by channel): COUNT from messages grouped by channel\n   - Cards with icon, value, label, optional trend indicator\n\n2. **Active Hunts List:**\n   - Query hunts WHERE status = 'active' AND organizationId = current\n   - Each row shows: name, platform badge, lead count, contacted count, last scan time\n   - Status indicator (green dot for active)\n   - Quick actions: pause/resume button, edit link\n   - Empty state with CTA to create first hunt\n\n3. **Quick Actions:**\n   - Primary CTA button: \"Nouvelle Recherche\" (create hunt)\n   - Trial/subscription status banner (if applicable)\n\n4. **Components:**\n   - `src/components/dashboard/stat-card.tsx`\n   - `src/components/dashboard/hunt-list-item.tsx`\n   - Use Server Components for data fetching, Client Components only for interactivity\n\n5. **Data Fetching Pattern:**\n   ```typescript\n   const db = await createDrizzleSupabaseClient();\n   const stats = await db.rls((tx) => \n     tx.select({ count: sql<number>`count(*)` })\n       .from(leads)\n       .where(eq(leads.organizationId, orgId))\n   );\n   ```",
        "testStrategy": "1. Verify stats queries return correct counts. 2. Test empty state renders when no hunts exist. 3. Verify hunt list updates after pause/resume action. 4. Test loading states and error handling.",
        "priority": "high",
        "dependencies": [
          "2",
          "3",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T15:57:11.762Z"
      },
      {
        "id": "9",
        "title": "Build Leads Pipeline with Kanban and List Views",
        "description": "Implement the leads CRM view with draggable Kanban board (Nouveau/Contacté/Relance/Négociation/Gagné/Perdu) and table list view. Reference: 02-crm-kanban-view.png",
        "details": "Create pipeline in `src/app/(app)/leads/page.tsx`:\n\n1. **View Toggle (Client Component):**\n   - Tab buttons: Kanban | Liste\n   - Persist preference in localStorage or URL param\n\n2. **Filter Bar:**\n   - Hunt dropdown (filter by source hunt)\n   - Assigned user dropdown (filter by assignee)\n   - Date range picker (createdAt filter)\n   - Search input (search vehicle title/description)\n   - Filters update URL search params for shareable views\n\n3. **Kanban View:**\n   - 6 columns matching stages: nouveau, contacte, relance, negociation, gagne, perdu\n   - Drag-and-drop between columns (use @dnd-kit or react-beautiful-dnd)\n   - Lead cards show: thumbnail, title, price, location, phone badge, platform badge\n   - On drop: update lead stage via Server Action, log activity\n   - Optimistic UI update for smooth DX\n\n4. **List View:**\n   - Table with sortable columns: vehicle, price, location, stage (dropdown), assigned, date\n   - Checkbox for bulk selection\n   - Bulk actions: change stage, assign to user\n   - Pagination with page size options\n\n5. **Lead Card Component:**\n   - `src/components/leads/lead-card.tsx`\n   - Click opens Lead Detail Drawer (Task 10)\n   - Show WhatsApp/phone icon if has phone number\n\n6. **Server Actions:**\n   - `updateLeadStage(leadId, newStage)` - updates stage, logs activity\n   - `bulkUpdateLeads(leadIds, updates)` - batch operations",
        "testStrategy": "1. Drag lead between stages, verify DB update and optimistic UI. 2. Apply filters, verify correct leads shown. 3. Sort table by price, verify ordering. 4. Bulk select and update, verify all records changed.",
        "priority": "high",
        "dependencies": [
          "3",
          "7"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Leads Page Foundation with View Toggle and Filter Bar",
            "description": "Build the main leads page at `src/app/(app)/leads/page.tsx` with a Server Component for data fetching and a Client Component for view toggle (Kanban/Liste) and filter bar. Install @dnd-kit packages for drag-and-drop functionality.",
            "dependencies": [],
            "details": "1. Install @dnd-kit/core and @dnd-kit/sortable packages via pnpm. 2. Create `src/app/(app)/leads/page.tsx` as Server Component that fetches leads with relations (ad, hunt, assignedTo) using `createDrizzleSupabaseClient()`. 3. Create `src/components/leads/leads-page-client.tsx` as Client Component containing: (a) View toggle tabs (Kanban | Liste) using URL search params (`?view=kanban|list`) with useSearchParams hook; (b) Filter bar with: Hunt dropdown (fetched from server), Assigned user dropdown (org members), Date range picker (createdAt), Search input (vehicle title). 4. Filters should update URL search params for shareable/bookmarkable views. 5. Update sidebar navigation href from `/pipeline` to `/leads` to match the actual route.",
            "status": "done",
            "testStrategy": "1. Navigate to /leads, verify page loads without errors. 2. Toggle between Kanban and List views, verify URL params update. 3. Apply filters, verify URL params update correctly. 4. Refresh page with filters in URL, verify filters are preserved.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:33:57.607Z"
          },
          {
            "id": 2,
            "title": "Build Kanban View with Drag-and-Drop Columns",
            "description": "Implement the Kanban board view with 6 columns (nouveau, contacte, relance, negociation, gagne, perdu) using @dnd-kit library. Include drag-and-drop functionality between columns with optimistic UI updates.",
            "dependencies": [
              1
            ],
            "details": "1. Create `src/components/leads/kanban-view.tsx` Client Component using @dnd-kit/core DndContext and @dnd-kit/sortable SortableContext. 2. Create `src/components/leads/kanban-column.tsx` for each stage column with: (a) Column header showing stage name (French labels: Nouveau, Contacté, Relance, Négociation, Gagné, Perdu) and lead count; (b) Droppable area using useDroppable hook; (c) Visual feedback during drag (border highlight). 3. Implement onDragEnd handler that: (a) Identifies source and target columns; (b) Performs optimistic UI update using React state; (c) Calls updateLeadStage Server Action (Task 5); (d) Reverts on error with toast notification. 4. Use `position` field from leads schema for ordering within columns. 5. Style with dark theme matching existing design (zinc-800 borders, amber-500 accents).",
            "status": "done",
            "testStrategy": "1. Drag lead card from 'Nouveau' to 'Contacté', verify card moves immediately (optimistic UI). 2. Verify database is updated after drag. 3. Simulate network error, verify card returns to original position. 4. Drag multiple leads, verify order is maintained within columns.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:37:06.612Z"
          },
          {
            "id": 3,
            "title": "Build Lead Card Component for Kanban and List Views",
            "description": "Create a reusable LeadCard component displaying thumbnail, title, price, location, phone badge, and platform badge. Card click should be wired for Lead Detail Drawer integration (Task 10).",
            "dependencies": [
              1
            ],
            "details": "1. Create `src/components/leads/lead-card.tsx` as Client Component with props: lead data (with ad relation), onSelect callback, isDragging state. 2. Card layout showing: (a) Thumbnail from ad.picture with fallback placeholder; (b) Vehicle title (ad.title) truncated to 2 lines; (c) Price formatted as EUR with French locale; (d) Location from ad.zipcode relation; (e) Phone badge (green icon if ad.hasPhone && ad.phoneNumber); (f) WhatsApp badge (amber icon if ad.isWhatsappPhone); (g) Platform badge based on ad URL domain detection (Leboncoin logo/text). 3. Wrap in @dnd-kit useSortable for Kanban draggable support. 4. onClick triggers onSelect callback passing lead ID for drawer opening. 5. Visual states: hover (subtle border glow), dragging (opacity reduced, shadow), selected (amber border). 6. Show stage badge as colored dot matching column color scheme.",
            "status": "done",
            "testStrategy": "1. Verify card displays all data fields correctly. 2. Click card, verify onSelect callback fires with correct lead ID. 3. Verify phone/WhatsApp badges show only when data exists. 4. Test with missing thumbnail, verify fallback renders.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:35:51.263Z"
          },
          {
            "id": 4,
            "title": "Build List View with Sortable Table and Bulk Actions",
            "description": "Implement the table list view with sortable columns, checkbox selection for bulk operations, and pagination. Include inline stage dropdown and assign user dropdown per row.",
            "dependencies": [
              1,
              3
            ],
            "details": "1. Create `src/components/leads/list-view.tsx` Client Component with table structure. 2. Table columns: (a) Checkbox for selection (header checkbox for select all); (b) Vehicle (thumbnail + title from LeadCard component); (c) Price (sortable, formatted EUR); (d) Location (zipcode.name); (e) Stage (dropdown select inline, calls updateLeadStage on change); (f) Assigned (dropdown with org members, calls assignLead action); (g) Date (createdAt formatted, sortable). 3. Sorting: Click column header to toggle sort direction, update URL params (?sort=price&dir=asc). 4. Bulk actions bar (appears when selection > 0): (a) Change stage dropdown; (b) Assign to user dropdown; (c) Selection count display. 5. Pagination component at bottom: page size options (10, 25, 50), page navigation, total count. 6. Use URL params for pagination (?page=1&pageSize=25). 7. Style table with zinc-800 borders, alternating row backgrounds, hover states.",
            "status": "done",
            "testStrategy": "1. Sort by price column, verify leads reorder and URL updates. 2. Select multiple leads via checkboxes, verify bulk action bar appears. 3. Bulk change stage, verify all selected leads update. 4. Change page size, verify correct number of leads displayed. 5. Inline change stage on single row, verify immediate update.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:38:19.136Z"
          },
          {
            "id": 5,
            "title": "Create Server Actions for Lead Stage Updates and Bulk Operations",
            "description": "Implement Server Actions for updateLeadStage, bulkUpdateLeads, and assignLead operations. Include activity logging to lead_notes table for audit trail.",
            "dependencies": [],
            "details": "1. Create `src/app/(app)/leads/actions.ts` with 'use server' directive. 2. Implement `updateLeadStage(leadId: string, newStage: LeadStage)`: (a) Validate stage is valid using leadStages array from schema; (b) Get current user via createDrizzleSupabaseClient(); (c) Update lead record with new stage and updatedAt; (d) Insert activity note: 'Stage changé de {oldStage} à {newStage}' with createdById; (e) Revalidate /leads path. 3. Implement `bulkUpdateLeads(leadIds: string[], updates: { stage?: LeadStage, assignedToId?: string })`: (a) Validate all inputs; (b) Update all leads in transaction; (c) Log activity for each lead; (d) Revalidate path. 4. Implement `assignLead(leadId: string, assignedToId: string | null)`: (a) Update lead.assignedToId; (b) Log activity note; (c) Revalidate. 5. Implement `getLeadsWithFilters(filters: LeadFilters)` for server-side filtering supporting: huntId, assignedToId, dateRange, search, stage, sort, pagination. 6. Use Drizzle type-safe queries with RLS enforced via createDrizzleSupabaseClient().",
            "status": "done",
            "testStrategy": "1. Call updateLeadStage, verify lead stage changes in DB and activity logged. 2. Call bulkUpdateLeads with 5 leads, verify all update atomically. 3. Verify RLS prevents updating leads from other organizations. 4. Test with invalid stage value, verify error is thrown. 5. Verify revalidation triggers UI refresh.",
            "parentId": "undefined",
            "updatedAt": "2026-01-21T15:34:49.351Z"
          }
        ],
        "updatedAt": "2026-01-21T15:38:19.136Z"
      },
      {
        "id": "10",
        "title": "Build Lead Detail Drawer and Full Page Views",
        "description": "Implement the lead detail drawer (quick access from pipeline) and full page view with complete vehicle specs, seller info, message history, and action buttons. Reference: 17-18-19-20 screenshots.",
        "details": "Create lead detail components:\n\n1. **Lead Drawer (`src/components/leads/lead-drawer.tsx`):**\n   - Slide-in panel from right (use Headless UI Dialog or custom)\n   - Image gallery with thumbnails (ad.picture + parse pictures array)\n   - Price, location, post date display\n   - Stage selector dropdown (inline change)\n   - Assigned user selector dropdown\n   - Quick action buttons row:\n     - WhatsApp: generate wa.me/{phone}?text={template} link, open in new tab\n     - SMS: trigger send SMS modal (requires credits)\n     - Voice: trigger send voice modal (requires credits)\n     - Platform: link to open original listing URL\n   - Reminders section: date picker + add reminder button\n   - Notes section: textarea with save button, list existing notes\n   - \"Voir détails complets\" button to open full page\n\n2. **Full Page View (`src/app/(app)/leads/[id]/page.tsx`):**\n   - All drawer content plus:\n   - Complete vehicle specs grid: brand, model, year, mileage, fuel, gearbox, color, Crit'Air, seats, etc. (from ads table relations)\n   - Seller info section: name, phone, type badge (private/pro based on acceptSalesmen)\n   - Full listing description (ad.description)\n   - Message history timeline (query messages for this lead)\n   - Activity log timeline (query lead_activities)\n\n3. **Data Fetching:**\n   - Query lead with all ad relations (brand, fuel, gearbox, etc.)\n   - Parallel queries for notes, reminders, messages, activities\n\n4. **Server Actions:**\n   - `addLeadNote(leadId, content)` - creates note, logs activity\n   - `addLeadReminder(leadId, dueAt, note)` - creates reminder\n   - `sendWhatsAppMessage(leadId, templateId)` - logs message attempt (MVP: just opens link)",
        "testStrategy": "1. Open drawer from Kanban, verify data loads correctly. 2. Change stage in drawer, verify pipeline updates. 3. Add note and reminder, verify persistence. 4. Click WhatsApp button, verify wa.me link opens with correct phone. 5. Navigate to full page, verify all specs displayed.",
        "priority": "high",
        "dependencies": [
          "3",
          "5",
          "9"
        ],
        "status": "done",
        "subtasks": [
          {
            "id": 1,
            "title": "Create Lead Drawer Component with Image Gallery and Basic Info",
            "description": "Build the lead drawer slide-in panel component with image gallery, basic ad information display, and close functionality. This is the foundation for the quick-access lead details view.",
            "dependencies": [],
            "details": "Create `src/components/leads/lead-drawer.tsx` as a client component using Headless UI Dialog or custom implementation. Implement slide-in animation from right side with overlay backdrop. Build image gallery component that displays ad.picture as main image with thumbnails parsed from the pictures JSON array. Include navigation arrows for browsing images. Display basic ad information: price (formatted with currency), location (from zipcode relation), and post date (formatted relative time). Add close button (X icon) in top-right corner. Accept leadId as prop and fetch lead data with all ad relations (brand, model, fuel, gearbox, zipcode, etc.) using server action. Handle loading and error states gracefully.",
            "status": "done",
            "testStrategy": "1. Open drawer by clicking lead card from Kanban view, verify slide-in animation works smoothly. 2. Verify main image displays correctly with fallback for missing images. 3. Click thumbnail images, verify main image updates. 4. Verify price, location, and date display with correct formatting. 5. Click close button or overlay, verify drawer closes. 6. Test with lead that has no images, verify graceful fallback UI.",
            "updatedAt": "2026-01-22T16:21:11.840Z",
            "parentId": "undefined"
          },
          {
            "id": 2,
            "title": "Implement Stage and Assignment Selectors in Drawer",
            "description": "Add interactive stage selector dropdown and assigned user selector dropdown to the lead drawer, enabling inline updates to lead pipeline status and assignment.",
            "dependencies": [
              1
            ],
            "details": "Add stage selector dropdown component (use Headless UI Listbox) that displays current lead stage with colored badge. Include all 6 stages: Nouveau, Contacté, Relance, Négociation, Gagné, Perdu with appropriate colors matching the Kanban view. Create server action `updateLeadStage(leadId, newStage)` that updates the leads table, sets updatedAt, and logs activity in lead_activities. Add assigned user selector dropdown that shows current assignee (account name + avatar) or 'Non assigné' placeholder. Populate dropdown with all organization members (query accounts by organizationId). Create server action `updateLeadAssignment(leadId, assignedToId)` that updates assignedToId field and logs activity. Implement optimistic UI updates for both selectors to provide instant feedback. Add permission check - only organization members can update assignments.",
            "status": "done",
            "testStrategy": "1. Change lead stage in drawer, verify database updates immediately and Kanban view reflects change. 2. Assign lead to different user, verify assignment updates and activity log created. 3. Test optimistic UI - verify dropdown shows new value before server response. 4. Verify only organization members appear in assignee dropdown. 5. Test error handling - simulate network failure and verify error message displayed.",
            "parentId": "undefined",
            "updatedAt": "2026-01-22T16:24:37.159Z"
          },
          {
            "id": 3,
            "title": "Build Quick Action Buttons Row for Communication Channels",
            "description": "Implement the quick action buttons for WhatsApp, SMS, Voice, and Platform link, enabling rapid outreach to sellers directly from the drawer.",
            "dependencies": [
              1
            ],
            "details": "Create action buttons row with 4 buttons: WhatsApp (green), SMS (blue), Voice (purple), Platform (gray). For WhatsApp button: import renderTemplate from whatsapp.services.ts, generate wa.me/{phone}?text={encodedMessage} link using lead's phone and organization's default WhatsApp template, open link in new tab (_blank), log message attempt in messages table with type='whatsapp'. For SMS button: trigger SMS modal component (create modal shell, full implementation deferred), disable if organization has no SMS credits, show tooltip 'Nécessite des crédits'. For Voice button: trigger voice modal component (create modal shell), disable if no credits, show tooltip. For Platform button: create direct link to ad.url (original listing), open in new tab with external link icon. Add loading states for each button during server actions. Include error handling with toast notifications for failed actions.",
            "status": "done",
            "testStrategy": "1. Click WhatsApp button on lead with valid phone, verify wa.me link opens in new tab with correctly formatted message. 2. Verify template variables like {titre_annonce} are replaced with actual ad data. 3. Check message logged in messages table with correct leadId and type. 4. Click Platform button, verify original listing URL opens correctly. 5. Test with lead missing phone number - WhatsApp button should be disabled with tooltip. 6. Verify SMS/Voice buttons are disabled when credits are insufficient.",
            "parentId": "undefined",
            "updatedAt": "2026-01-22T16:27:49.148Z"
          },
          {
            "id": 4,
            "title": "Add Notes and Reminders Sections to Drawer",
            "description": "Implement the notes and reminders functionality in the drawer, allowing users to add contextual information and schedule follow-ups for leads.",
            "dependencies": [
              1
            ],
            "details": "Create notes section with textarea input (placeholder: 'Ajouter une note...'), 'Sauvegarder' button, and list of existing notes sorted by createdAt DESC. Each note displays content, author name + avatar, and timestamp (relative format like '2 hours ago'). Implement server action `addLeadNote(leadId, content)` that inserts into lead_notes table with organizationId, leadId, createdById (current user), content, and logs activity in lead_activities. Create reminders section with date-time picker component (use react-day-picker or similar), optional note textarea, and 'Ajouter' button. Display list of upcoming reminders sorted by dueAt ASC, each showing due date/time, note, and delete icon. Implement server action `addLeadReminder(leadId, dueAt, note)` that inserts into lead_reminders table and creates notification. Add validation: notes require non-empty content, reminders require future dueAt. Include optimistic UI updates for instant feedback.",
            "status": "done",
            "testStrategy": "1. Add note with content, verify it appears in list immediately and persists after refresh. 2. Verify note shows correct author name and timestamp. 3. Create reminder with date picker, verify it saves and displays in list. 4. Test validation - submit empty note shows error, past date for reminder shows error. 5. Delete reminder, verify it removes from database and UI. 6. Check lead_activities table contains entries for note and reminder creation.",
            "parentId": "undefined",
            "updatedAt": "2026-01-22T17:07:11.102Z"
          },
          {
            "id": 5,
            "title": "Build Full Lead Detail Page with Complete Vehicle Specs and Timeline",
            "description": "Create the comprehensive full-page lead detail view accessible from the drawer's 'Voir détails complets' button, displaying all vehicle specifications, seller information, message history, and activity timeline.",
            "dependencies": [
              1,
              2,
              3,
              4
            ],
            "details": "Create `src/app/(app)/leads/[id]/page.tsx` as server component that fetches lead with all relations (ad, brand, model, fuel, gearbox, bodyType, zipcodes, etc.) plus parallel queries for notes, reminders, messages, and activities. Build page layout with sections: (1) Hero section: reuse image gallery component, price, location, stage badge, assigned user, action buttons row from drawer. (2) Vehicle specs grid: display brand.name, model.name, year, mileage (formatted with km), fuel.name, gearbox.name, color, critAir, seats, doors, fiscalPower, din, registration, firstHand (boolean badge), from ad relations. Use responsive grid layout (2-3 columns). (3) Seller info card: display seller name (ad.account or derived), phone (clickable tel: link), type badge ('Particulier' if acceptSalesmen=false, 'Professionnel' if true). (4) Description section: render ad.description with preserved line breaks. (5) Message history timeline: query messages for this lead ordered by sentAt DESC, display each with type icon (WhatsApp/SMS/Voice), status badge (sent/delivered/failed), content preview, timestamp. (6) Activity log timeline: query lead_activities ordered by createdAt DESC, display each with action type, user who performed action, timestamp. Add 'Retour au pipeline' back button. Implement breadcrumb navigation: Leads > Lead #ID. Add metadata for SEO with ad title.",
            "status": "done",
            "testStrategy": "1. Open full page from drawer 'Voir détails complets' button, verify all sections render with correct data. 2. Verify vehicle specs grid displays all fields with proper formatting (mileage with km, boolean badges for firstHand). 3. Check seller info shows correct type badge based on acceptSalesmen flag. 4. Verify description preserves line breaks and formatting. 5. Confirm message timeline shows all messages with correct icons and status badges. 6. Verify activity log displays all activities (stage changes, notes, assignments) chronologically. 7. Test with lead missing optional fields (e.g., no color, no critAir), verify graceful handling. 8. Click breadcrumb, verify navigation back to leads pipeline.",
            "parentId": "undefined",
            "updatedAt": "2026-01-22T17:11:40.504Z"
          }
        ],
        "updatedAt": "2026-01-22T17:11:40.504Z"
      },
      {
        "id": "11",
        "title": "Build Hunt Creation and Edit Interface",
        "description": "Implement hunt creation/edit form with URL paste tab and search builder tab, plus outreach settings. Reference: 14-15-16 screenshots.",
        "details": "Create hunt forms in `src/app/(app)/hunts/`:\n\n1. **Hunt List Page (`page.tsx`):**\n   - Grid/list of all organization hunts\n   - Each card shows: name, status badge, stats (leads, contacted), platform, last scan\n   - Actions: Edit, Pause/Resume toggle, Delete with confirmation\n   - \"Nouvelle Recherche\" primary CTA button\n\n2. **Hunt Create/Edit Page (`new/page.tsx` and `[id]/edit/page.tsx`):**\n   - Name input field\n   - Tabs for search definition:\n     - **URL Paste Tab:** Text input for Leboncoin search URL, parse and validate URL format\n     - **Search Builder Tab (Phase 2, stub for MVP):** Platform select, price range inputs, mileage range, brand multi-select, location + radius\n   - Auto-refresh toggle\n   \n3. **Outreach Settings Section:**\n   - Toggle switches for each channel: Leboncoin, WhatsApp, SMS\n   - When toggle enabled, show template selector dropdown (query message_templates for org)\n   - Hint text explaining what each channel does\n\n4. **Form Handling:**\n   - Use react-hook-form or Next.js Server Actions with useFormState\n   - Validation: name required, URL or builder filters required\n   - On submit: create/update hunt record, redirect to hunts list\n\n5. **Components:**\n   - `src/components/hunts/hunt-form.tsx` - main form component\n   - `src/components/hunts/url-paste-tab.tsx`\n   - `src/components/hunts/search-builder-tab.tsx` (placeholder for Phase 2)\n   - `src/components/hunts/outreach-settings.tsx`",
        "testStrategy": "1. Create hunt with URL, verify saved correctly. 2. Edit hunt, change name and template, verify updates. 3. Toggle pause/resume, verify status changes. 4. Test validation - submit without name shows error. 5. Delete hunt with confirmation.",
        "priority": "medium",
        "dependencies": [
          "2",
          "4",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T17:38:31.517Z"
      },
      {
        "id": "12",
        "title": "Build Message Templates Management Interface",
        "description": "Implement templates list, creation form for text templates with variable insertion, and voice recording UI with duration validation. Reference: 09-12 screenshots.",
        "details": "Create templates interface in `src/app/(app)/templates/`:\n\n1. **Templates List Page (`page.tsx`):**\n   - Tabs or filter: Text | Voice (or show all with type badge)\n   - Grid of template cards showing: name, type icon, channel badge, preview snippet\n   - Edit/Delete actions per template\n   - \"Nouveau Template\" CTA button\n\n2. **Text Template Form (`new/page.tsx` with type param):**\n   - Name input field\n   - Channel select: WhatsApp | SMS | Leboncoin\n   - Message content textarea\n   - Variable insertion toolbar: buttons for each variable ({titre_annonce}, etc.)\n   - Click variable button inserts at cursor position\n   - \"Suggérer par IA\" button (stub for Phase 2 - just shows toast \"Bientôt disponible\")\n   - Live preview panel showing rendered message with sample data\n\n3. **Voice Template Form:**\n   - Name input field\n   - Recording UI:\n     - Start/Stop recording button (use MediaRecorder API)\n     - Duration timer display during recording\n     - Validation: must be 15-55 seconds (show error if outside range)\n   - OR file upload input for pre-recorded audio\n   - Playback preview with audio player\n   - On save: upload to Supabase Storage, store URL in template\n\n4. **Components:**\n   - `src/components/templates/text-template-form.tsx`\n   - `src/components/templates/voice-template-form.tsx`\n   - `src/components/templates/variable-toolbar.tsx`\n   - `src/components/templates/audio-recorder.tsx` (Client Component)\n\n5. **Server Actions:**\n   - `createTemplate(data)` - handles text creation\n   - `uploadVoiceTemplate(formData)` - uploads audio to Storage, creates template",
        "testStrategy": "1. Create text template with variables, verify stored. 2. Insert variable via toolbar, verify inserted at cursor. 3. Record voice <15s, verify error shown. 4. Record valid 30s voice, verify upload and save. 5. Play back saved voice template.",
        "priority": "medium",
        "dependencies": [
          "4",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T17:22:34.423Z"
      },
      {
        "id": "13",
        "title": "Build Settings Page with Connected Accounts and Team Management",
        "description": "Implement settings interface with tabs for connected accounts (Leboncoin, WhatsApp QR, SMS API), filters, messages settings, and team/organization management. Reference: 03-08 screenshots.",
        "details": "Create settings in `src/app/(app)/settings/page.tsx`:\n\n1. **Tab Navigation:** Connected Accounts | Filters | Messages | Team\n\n2. **Connected Accounts Tab:**\n   - Leboncoin: Connection status badge, \"Connecter\" button (links to Chrome extension install - MVP: just info text)\n   - WhatsApp: QR code placeholder (Phase 2 - show \"Bientôt disponible\" for direct integration)\n   - SMS Mobile API: API key input field with mask, save button\n   - Store API keys in organization settings (encrypted if possible)\n\n3. **Filters Tab:**\n   - \"Refus des professionnels\" toggle with description\n   - Examples list: \"pas d'agence\", \"particulier seulement\"\n   - Save updates organization settings\n\n4. **Messages Tab:**\n   - \"Réinitialisation quotidienne\" toggle - resets message counters at midnight\n   - \"Ignorer les annonces avec téléphone\" toggle - skip auto-messaging for phone-visible listings\n   - Save updates organization settings\n\n5. **Team Tab:**\n   - Organization name input field (editable by owner)\n   - \"Autoriser la réassignation\" toggle\n   - \"Restreindre la visibilité\" toggle\n   - Members list table: name, email, role badge, remove button (owner can't remove self)\n   - Invite form: email input, role dropdown (Utilisateur/Admin), send button\n   - Pending invitations list with resend/cancel actions\n\n6. **Server Actions:**\n   - `updateOrganizationSettings(settings)` - partial update\n   - `inviteTeamMember(email, role)` - creates invitation, sends email (stub email for MVP)\n   - `removeTeamMember(memberId)` - removes membership\n   - `cancelInvitation(invitationId)` - deletes invitation",
        "testStrategy": "1. Change org name, verify persisted. 2. Toggle filter setting, verify saved. 3. Invite member, verify invitation created. 4. Remove member (non-owner), verify removed. 5. Try remove owner, verify blocked.",
        "priority": "medium",
        "dependencies": [
          "1",
          "7"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T16:02:39.811Z"
      },
      {
        "id": "14",
        "title": "Integrate Hunt Matching with Lead Creation",
        "description": "Daily hunt job that matches ads against user hunt criteria, sends messages, and creates both contactedAds and leads records. Implemented in src/actions/hunt.actions.ts with runDailyHunts().",
        "status": "done",
        "dependencies": [
          "2",
          "3"
        ],
        "priority": "high",
        "details": "✅ IMPLEMENTED in `src/actions/hunt.actions.ts`:\n\n**What was built:**\n- `runDailyHunts()` - Main entry point for daily cron job\n- `fetchAllActiveHunts()` - Queries active baseFilters (hunts)\n- `contactAdsOwners()` - Matches ads, sends messages, creates contactedAds + leads\n- Uses existing `getMatchingAds()` from ad.actions.ts\n- Creates both `contactedAds` (history) and `leads` (CRM) with duplicate prevention\n- Terminology standardized to \"hunt\" throughout\n\n**Files modified:**\n- `src/actions/hunt.actions.ts` (renamed from prospecting.actions.ts)\n- `src/types/hunt.types.ts` (renamed from prospecting.types.ts)\n- `src/app/api/prospecting/route.ts` (updated imports)\n\nOriginal task description below for reference:\n\nCreate a Hunt Matching Job system in `src/actions/hunt-matching.actions.ts`:\n\n**Architecture Overview:**\n- Lobstr Job: Already exists (`src/actions/lobstr.actions.ts`) - independently scrapes ads from LeBonCoin into the `ads` table\n- Hunt Matching Job (THIS TASK): Periodically matches existing ads against user hunts and creates leads\n\n**1. Core Matching Function:**\n```typescript\nexport async function processHuntMatches(huntId: string): Promise<{ created: number; skipped: number }> {\n  const dbClient = await createDrizzleSupabaseClient();\n  \n  // Fetch hunt with relations (reuse existing query pattern from prospecting.actions.ts:22-32)\n  const hunt = await dbClient.admin.query.baseFilters.findFirst({\n    where: eq(baseFilters.id, huntId),\n    with: { location: true, subTypes: true, brands: true }\n  });\n  \n  if (!hunt || hunt.status !== 'active') return { created: 0, skipped: 0 };\n  \n  // Reuse existing getMatchingAds from ad.actions.ts:155-247\n  const matchingAds = await getMatchingAds(hunt, { dbClient, bypassRLS: true });\n  \n  // Check for existing leads (unique constraint: organizationId + adId)\n  const existingLeads = await dbClient.admin.select({ adId: leads.adId })\n    .from(leads)\n    .where(and(\n      eq(leads.organizationId, hunt.organizationId),\n      inArray(leads.adId, matchingAds.map(a => a.id))\n    ));\n  \n  const existingAdIds = new Set(existingLeads.map(l => l.adId));\n  const newAds = matchingAds.filter(ad => !existingAdIds.has(ad.id));\n  \n  // Create leads for new matches only\n  if (newAds.length > 0) {\n    await dbClient.admin.insert(leads).values(\n      newAds.map(ad => ({\n        organizationId: hunt.organizationId,\n        huntId: huntId,\n        adId: ad.id,\n        stage: 'nouveau',\n        position: 0\n      }))\n    );\n  }\n  \n  // Update hunt lastScanAt timestamp\n  await dbClient.admin.update(baseFilters)\n    .set({ lastScanAt: new Date() })\n    .where(eq(baseFilters.id, huntId));\n  \n  return { created: newAds.length, skipped: existingAdIds.size };\n}\n```\n\n**2. Bulk Processing for All Active Hunts:**\n```typescript\nexport async function processAllActiveHunts(): Promise<void> {\n  const dbClient = await createDrizzleSupabaseClient();\n  \n  // Fetch all active hunts with autoRefresh enabled\n  const activeHunts = await dbClient.admin.query.baseFilters.findMany({\n    where: and(\n      eq(baseFilters.status, 'active'),\n      eq(baseFilters.autoRefresh, true)\n    ),\n    columns: { id: true }\n  });\n  \n  // Process with controlled concurrency (similar to prospecting.actions.ts:39-64)\n  const concurrency = 5;\n  const queue = [...activeHunts];\n  const inFlight: Promise<void>[] = [];\n  \n  while (queue.length || inFlight.length) {\n    while (inFlight.length < concurrency && queue.length) {\n      const hunt = queue.shift()!;\n      const promise = processHuntMatches(hunt.id)\n        .catch(console.error)\n        .finally(() => {\n          const idx = inFlight.indexOf(promise);\n          if (idx !== -1) inFlight.splice(idx, 1);\n        });\n      inFlight.push(promise);\n    }\n    if (inFlight.length) await Promise.race(inFlight);\n  }\n}\n```\n\n**3. API Route for Cron Trigger (`src/app/api/cron/hunt-matching/route.ts`):**\n```typescript\nexport async function GET(request: Request) {\n  // Verify cron secret for security\n  const authHeader = request.headers.get('authorization');\n  if (authHeader !== `Bearer ${process.env.CRON_SECRET}`) {\n    return new Response('Unauthorized', { status: 401 });\n  }\n  \n  await processAllActiveHunts();\n  return Response.json({ success: true });\n}\n```\n\n**Key Files to Reference:**\n- `src/actions/ad.actions.ts:155-247` - Reuse `getMatchingAds` for filter matching\n- `src/actions/prospecting.actions.ts:39-64` - Reuse concurrency pattern\n- `src/schema/filter.schema.ts` - Hunt schema (`baseFilters` table)\n- `src/schema/lead.schema.ts:76-79` - Unique constraint prevents duplicates\n\n**Duplicate Prevention:** The `leads` table has a unique constraint on `(organizationId, adId)` - same ad for same org = lead creation skipped",
        "testStrategy": "1. Create active hunt with specific filters. 2. Add matching ads to ads table. 3. Trigger POST /api/prospecting. 4. Verify both contactedAds and leads tables populated. 5. Run again - verify no duplicate leads (unique constraint on organizationId+adId). 6. Check leads appear in Kanban with stage='contacte'.",
        "subtasks": [],
        "updatedAt": "2026-01-22T14:43:14.134Z"
      },
      {
        "id": "15",
        "title": "Implement WhatsApp wa.me Link Messaging (MVP)",
        "description": "Implement MVP WhatsApp messaging by generating wa.me links with pre-filled template messages. When user clicks WhatsApp button on a lead, open the link with the phone number and rendered message template.",
        "details": "Create WhatsApp service in `src/services/whatsapp.services.ts`:\n\n1. **Template Rendering Function:**\n   ```typescript\n   export function renderTemplate(template: string, lead: LeadWithAd): string {\n     const variables = {\n       '{titre_annonce}': lead.ad.title,\n       '{ia_titre_annonce}': cleanTitle(lead.ad.title), // remove VENDS, À VENDRE, etc.\n       '{ia_type_de_bien}': lead.ad.type?.name || 'Véhicule',\n       '{lieu_annonce}': lead.ad.zipcode?.name || '',\n       '{prix_annonce}': formatPrice(lead.ad.price),\n     };\n     \n     return Object.entries(variables).reduce(\n       (text, [key, value]) => text.replaceAll(key, value),\n       template\n     );\n   }\n   ```\n\n2. **wa.me Link Generation:**\n   ```typescript\n   export function generateWhatsAppLink(phone: string, message: string): string {\n     // Ensure phone is in international format without +\n     const cleanPhone = phone.replace(/\\D/g, '');\n     const encodedMessage = encodeURIComponent(message);\n     return `https://wa.me/${cleanPhone}?text=${encodedMessage}`;\n   }\n   ```\n\n3. **Client Component Integration:**\n   - In lead-drawer.tsx, WhatsApp button onClick:\n     - Fetch default WhatsApp template for org (or show template picker)\n     - Render template with lead data\n     - Generate wa.me link\n     - window.open(link, '_blank')\n     - Log message attempt via Server Action\n\n4. **Message Logging Server Action:**\n   ```typescript\n   'use server'\n   export async function logWhatsAppAttempt(leadId: string, templateId: string, renderedContent: string) {\n     const db = await createDrizzleSupabaseClient();\n     await db.rls((tx) => tx.insert(messages).values({\n       leadId,\n       templateId,\n       channel: 'whatsapp',\n       content: renderedContent,\n       status: 'sent', // MVP: assume sent since we opened the link\n       sentAt: new Date(),\n       sentById: getCurrentUserId(),\n     }));\n     // Also log activity\n     await logLeadActivity(leadId, 'message_sent', { channel: 'whatsapp' });\n   }\n   ```\n\n5. **UI Feedback:** Show toast \"Message WhatsApp ouvert\" after clicking",
        "testStrategy": "1. Click WhatsApp on lead with phone, verify link opens with correct phone and message. 2. Verify template variables replaced correctly. 3. Check message logged in database. 4. Test with lead missing phone - button should be disabled or show warning.",
        "priority": "medium",
        "dependencies": [
          "4",
          "5",
          "10"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T17:40:54.276Z"
      },
      {
        "id": "16",
        "title": "Install Form Validation Dependencies",
        "description": "Install the required npm packages for form validation: react-hook-form, @hookform/resolvers, and zod for client and server-side validation.",
        "details": "Run pnpm to install required dependencies:\n\n```bash\npnpm add react-hook-form @hookform/resolvers zod\n```\n\nAfter installation, verify the packages are added to package.json dependencies:\n- react-hook-form (latest stable)\n- @hookform/resolvers (for Zod integration)\n- zod (schema validation library)\n\nVerify TypeScript types are properly resolved by checking no type errors appear in the IDE after installation. These packages integrate together as follows:\n- zod defines the validation schema\n- @hookform/resolvers/zod provides the zodResolver\n- react-hook-form's useForm accepts the resolver",
        "testStrategy": "1. Run `pnpm add` command and verify successful installation\n2. Check package.json includes all three dependencies\n3. Create a minimal test import in any component to verify modules resolve correctly:\n   ```typescript\n   import { useForm } from 'react-hook-form';\n   import { zodResolver } from '@hookform/resolvers/zod';\n   import { z } from 'zod';\n   ```\n4. Run `pnpm dev` to ensure no build errors",
        "priority": "high",
        "dependencies": [],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T18:50:38.035Z"
      },
      {
        "id": "17",
        "title": "Initialize shadcn/ui and Install Form Components",
        "description": "Initialize shadcn/ui in the project and install the required form-related components: Form, Input, Textarea, Select, Checkbox, and Button.",
        "details": "Initialize shadcn/ui:\n```bash\npnpm dlx shadcn@latest init\n```\n\nDuring init, configure for:\n- TypeScript: Yes\n- Style: Default (or match existing zinc/amber color scheme)\n- Base color: Zinc (to match existing dark theme)\n- CSS variables: Yes\n- Tailwind CSS config: tailwind.config.ts (or app/globals.css for Tailwind v4)\n- Components alias: @/components\n- Utils alias: @/lib/utils\n\nThen install required components:\n```bash\npnpm dlx shadcn@latest add form input textarea select checkbox button label\n```\n\nThe Form component from shadcn/ui is built on top of react-hook-form and provides:\n- FormField, FormItem, FormLabel, FormControl, FormDescription, FormMessage\n- Automatic error message display integration\n- Accessible form controls with proper aria attributes\n\nNote: The existing `src/components/ui/dropdown.tsx` should be kept as it may serve a different purpose than shadcn's Select.",
        "testStrategy": "1. Verify `components.json` is created at project root with correct configuration\n2. Check `src/components/ui/` contains new shadcn components (form.tsx, input.tsx, etc.)\n3. Verify `src/lib/utils.ts` is created with cn() helper function\n4. Run `pnpm dev` and ensure no build/type errors\n5. Import a component in any file to verify path aliases work:\n   ```typescript\n   import { Button } from '@/components/ui/button';\n   ```",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T18:53:49.808Z"
      },
      {
        "id": "18",
        "title": "Create Hunt Validation Schema",
        "description": "Create the Zod validation schema for hunt creation/edit forms in a new centralized validation schemas directory with French error messages.",
        "details": "Create directory `src/schemas/validation/` and add `hunt.validation.ts`:\n\n```typescript\nimport { z } from 'zod';\n\n// Outreach settings schema\nconst outreachSettingsSchema = z.object({\n  leboncoin: z.boolean().optional(),\n  whatsapp: z.boolean().optional(),\n  sms: z.boolean().optional(),\n}).optional();\n\n// Template IDs schema\nconst templateIdsSchema = z.object({\n  leboncoin: z.string().nullable().optional(),\n  whatsapp: z.string().nullable().optional(),\n  sms: z.string().nullable().optional(),\n}).optional();\n\n// Main hunt form schema\nexport const huntFormSchema = z.object({\n  name: z.string()\n    .min(1, 'Le nom est requis')\n    .max(100, 'Le nom ne peut pas dépasser 100 caractères'),\n  searchUrl: z.string()\n    .url('Veuillez entrer une URL valide')\n    .refine(\n      (url) => url.includes('leboncoin.fr'),\n      'L\\'URL doit provenir de Leboncoin'\n    ).optional(),\n  autoRefresh: z.boolean().default(true),\n  outreachSettings: outreachSettingsSchema,\n  templateIds: templateIdsSchema,\n});\n\n// Type inference for form data\nexport type HuntFormData = z.infer<typeof huntFormSchema>;\n\n// Server action schema (includes all fields)\nexport const createHuntSchema = huntFormSchema.extend({\n  locationId: z.number().positive('L\\'emplacement est requis'),\n  radiusInKm: z.number().min(0).default(0),\n  adTypeId: z.number().positive('Le type d\\'annonce est requis'),\n});\n\nexport type CreateHuntData = z.infer<typeof createHuntSchema>;\n```\n\nAlso create an index.ts barrel export file in the validation directory.",
        "testStrategy": "1. Verify schema file compiles without TypeScript errors\n2. Test schema validation manually:\n   ```typescript\n   const result = huntFormSchema.safeParse({ name: '' });\n   console.log(result.success); // false\n   console.log(result.error?.errors[0].message); // 'Le nom est requis'\n   ```\n3. Verify type inference works: `HuntFormData` should have correct field types\n4. Test URL validation rejects non-Leboncoin URLs\n5. Test all French error messages display correctly",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T18:55:10.144Z"
      },
      {
        "id": "19",
        "title": "Create Template Validation Schemas",
        "description": "Create Zod validation schemas for text and voice template forms with channel-specific validation rules and French error messages.",
        "details": "Create `src/schemas/validation/template.validation.ts`:\n\n```typescript\nimport { z } from 'zod';\nimport { messageChannels, type MessageChannel } from '@/schema/message-template.schema';\n\n// Text template validation schema\nexport const textTemplateSchema = z.object({\n  name: z.string()\n    .min(1, 'Le nom est requis')\n    .max(100, 'Le nom ne peut pas dépasser 100 caractères'),\n  channel: z.enum(['whatsapp', 'sms', 'leboncoin'] as const, {\n    required_error: 'Le canal est requis',\n    invalid_type_error: 'Canal invalide',\n  }),\n  content: z.string()\n    .min(1, 'Le contenu du message est requis')\n    .max(2000, 'Le contenu ne peut pas dépasser 2000 caractères'),\n  isDefault: z.boolean().default(false),\n});\n\nexport type TextTemplateFormData = z.infer<typeof textTemplateSchema>;\n\n// Voice template validation schema\nexport const voiceTemplateSchema = z.object({\n  name: z.string()\n    .min(1, 'Le nom est requis')\n    .max(100, 'Le nom ne peut pas dépasser 100 caractères'),\n  audioUrl: z.string()\n    .url('URL audio invalide')\n    .optional(),\n  audioDuration: z.number()\n    .min(15, 'La durée minimale est de 15 secondes')\n    .max(55, 'La durée maximale est de 55 secondes'),\n  isDefault: z.boolean().default(false),\n});\n\nexport type VoiceTemplateFormData = z.infer<typeof voiceTemplateSchema>;\n\n// Client-side voice template schema (before upload)\nexport const voiceTemplateClientSchema = z.object({\n  name: z.string().min(1, 'Le nom est requis'),\n  audioBlob: z.instanceof(Blob, {\n    message: 'Veuillez enregistrer ou importer un fichier audio',\n  }),\n  audioDuration: z.number()\n    .min(15, 'La durée minimale est de 15 secondes')\n    .max(55, 'La durée maximale est de 55 secondes'),\n  isDefault: z.boolean().default(false),\n});\n\nexport type VoiceTemplateClientData = z.infer<typeof voiceTemplateClientSchema>;\n```\n\nThe voice template has two schemas:\n1. Client schema validates the form before upload (uses Blob)\n2. Server schema validates after upload (uses URL string)",
        "testStrategy": "1. Test text template schema rejects empty name and content\n2. Test channel validation only accepts valid MessageChannel values\n3. Test voice duration validation:\n   - Reject duration < 15 seconds\n   - Reject duration > 55 seconds\n   - Accept duration between 15-55 seconds\n4. Verify all error messages are in French\n5. Test type inference for both schemas",
        "priority": "high",
        "dependencies": [
          "16"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T18:56:13.675Z"
      },
      {
        "id": "20",
        "title": "Create Lead and Settings Validation Schemas",
        "description": "Create Zod validation schemas for lead notes, reminders, and settings page forms with appropriate validation rules.",
        "details": "Create `src/schemas/validation/lead.validation.ts`:\n\n```typescript\nimport { z } from 'zod';\n\n// Lead note validation\nexport const leadNoteSchema = z.object({\n  content: z.string()\n    .min(1, 'Le contenu de la note est requis')\n    .max(5000, 'La note ne peut pas dépasser 5000 caractères'),\n});\n\nexport type LeadNoteFormData = z.infer<typeof leadNoteSchema>;\n\n// Lead reminder validation\nexport const leadReminderSchema = z.object({\n  dueAt: z.coerce.date()\n    .refine(\n      (date) => date > new Date(),\n      'La date doit être dans le futur'\n    ),\n  note: z.string()\n    .max(1000, 'La note ne peut pas dépasser 1000 caractères')\n    .optional(),\n});\n\nexport type LeadReminderFormData = z.infer<typeof leadReminderSchema>;\n```\n\nCreate `src/schemas/validation/settings.validation.ts`:\n\n```typescript\nimport { z } from 'zod';\n\n// Team invitation schema\nexport const teamInvitationSchema = z.object({\n  email: z.string()\n    .email('Adresse email invalide')\n    .min(1, 'L\\'email est requis'),\n  role: z.enum(['admin', 'user'], {\n    required_error: 'Le rôle est requis',\n  }),\n});\n\nexport type TeamInvitationFormData = z.infer<typeof teamInvitationSchema>;\n\n// Organization settings schema (for future use)\nexport const organizationSettingsSchema = z.object({\n  name: z.string()\n    .min(1, 'Le nom de l\\'organisation est requis')\n    .max(100, 'Le nom ne peut pas dépasser 100 caractères'),\n});\n\nexport type OrganizationSettingsFormData = z.infer<typeof organizationSettingsSchema>;\n```\n\nUpdate `src/schemas/validation/index.ts` to export all schemas.",
        "testStrategy": "1. Test note validation rejects empty content\n2. Test reminder validation rejects past dates\n3. Test email validation in team invitation schema\n4. Verify z.coerce.date() properly handles datetime-local input strings\n5. Test all error messages are in French",
        "priority": "medium",
        "dependencies": [
          "16"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "21",
        "title": "Refactor Hunt Form with react-hook-form and Zod",
        "description": "Refactor the HuntForm component to use react-hook-form with Zod validation, replacing useState-based form handling with proper form state management.",
        "details": "Refactor `src/components/hunts/hunt-form.tsx`:\n\n1. Replace useState calls with useForm hook:\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { huntFormSchema, type HuntFormData } from '@/schemas/validation/hunt.validation';\nimport { Form, FormField, FormItem, FormLabel, FormControl, FormMessage } from '@/components/ui/form';\nimport { Input } from '@/components/ui/input';\nimport { Checkbox } from '@/components/ui/checkbox';\nimport { Button } from '@/components/ui/button';\n\nconst form = useForm<HuntFormData>({\n  resolver: zodResolver(huntFormSchema),\n  defaultValues: {\n    name: hunt?.name ?? '',\n    autoRefresh: hunt?.autoRefresh ?? true,\n    outreachSettings: hunt?.outreachSettings ?? { leboncoin: false, whatsapp: false, sms: false },\n    templateIds: hunt?.templateIds ?? { leboncoin: null, whatsapp: null, sms: null },\n  },\n});\n```\n\n2. Replace form JSX with shadcn Form components:\n```typescript\n<Form {...form}>\n  <form onSubmit={form.handleSubmit(onSubmit)} className=\"space-y-6\">\n    <FormField\n      control={form.control}\n      name=\"name\"\n      render={({ field }) => (\n        <FormItem>\n          <FormLabel>Nom de la recherche</FormLabel>\n          <FormControl>\n            <Input placeholder=\"Ex: Peugeot 308 GTI Paris\" {...field} />\n          </FormControl>\n          <FormMessage />\n        </FormItem>\n      )}\n    />\n    {/* ... other fields */}\n  </form>\n</Form>\n```\n\n3. Update UrlPasteTab and SearchBuilderTab to work with form state (may need to use form.watch() and form.setValue())\n\n4. Fix the TypeScript error in search-builder-tab props by ensuring proper typing\n\n5. Update form submission to use validated data",
        "testStrategy": "1. Test form renders without errors\n2. Test validation errors display in French when submitting empty form\n3. Test name field shows error message for empty value\n4. Test successful form submission with valid data\n5. Test edit mode populates form with existing hunt data\n6. Verify autoRefresh checkbox works correctly\n7. Test form resets after successful submission\n8. Verify URL paste tab still functions correctly",
        "priority": "high",
        "dependencies": [
          "17",
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T19:14:21.613Z"
      },
      {
        "id": "22",
        "title": "Add Server-Side Validation to Hunt Actions",
        "description": "Add Zod schema validation to createHunt and updateHunt server actions, ensuring the same validation rules apply on both client and server.",
        "details": "Update `src/actions/hunt-crud.actions.ts`:\n\n1. Import and use the schema:\n```typescript\nimport { createHuntSchema, type CreateHuntData } from '@/schemas/validation/hunt.validation';\n\nexport async function createHunt(data: unknown) {\n  const supabase = await createClient();\n  const { data: userData } = await supabase.auth.getUser();\n\n  if (!userData.user) {\n    throw new Error('Non authentifié');\n  }\n\n  // Validate input with Zod\n  const parseResult = createHuntSchema.safeParse(data);\n  if (!parseResult.success) {\n    const errors = parseResult.error.flatten();\n    throw new Error(\n      Object.values(errors.fieldErrors).flat()[0] || 'Données invalides'\n    );\n  }\n\n  const validatedData = parseResult.data;\n  // ... rest of the function using validatedData\n}\n```\n\n2. Create a helper function for consistent error formatting:\n```typescript\nfunction formatZodError(error: z.ZodError): string {\n  const fieldErrors = error.flatten().fieldErrors;\n  const firstError = Object.values(fieldErrors).flat()[0];\n  return firstError || 'Données de formulaire invalides';\n}\n```\n\n3. Apply same pattern to updateHunt action\n\n4. Ensure error messages thrown are user-friendly French strings that can be displayed in the UI",
        "testStrategy": "1. Test createHunt with invalid data returns appropriate French error message\n2. Test createHunt with missing required fields is rejected\n3. Test createHunt with valid data succeeds\n4. Test that bypassing client-side validation still gets caught by server\n5. Test updateHunt validation similarly\n6. Verify error messages are consistent between client and server",
        "priority": "high",
        "dependencies": [
          "18"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T18:58:29.106Z"
      },
      {
        "id": "23",
        "title": "Refactor Template Forms with react-hook-form and Zod",
        "description": "Refactor TextTemplateForm and VoiceTemplateForm components to use react-hook-form with Zod validation and shadcn/ui components.",
        "details": "Refactor `src/components/templates/text-template-form.tsx`:\n\n1. Replace useState with useForm:\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { textTemplateSchema, type TextTemplateFormData } from '@/schemas/validation/template.validation';\n\nconst form = useForm<TextTemplateFormData>({\n  resolver: zodResolver(textTemplateSchema),\n  defaultValues: {\n    name: '',\n    channel: 'whatsapp',\n    content: '',\n    isDefault: false,\n  },\n});\n```\n\n2. Handle variable insertion with form state:\n```typescript\nconst handleInsertVariable = (variable: string) => {\n  const currentContent = form.getValues('content');\n  // Insert at cursor position logic...\n  form.setValue('content', newContent, { shouldValidate: true });\n};\n```\n\n3. Use shadcn Select for channel dropdown:\n```typescript\n<FormField\n  control={form.control}\n  name=\"channel\"\n  render={({ field }) => (\n    <FormItem>\n      <FormLabel>Canal</FormLabel>\n      <Select onValueChange={field.onChange} defaultValue={field.value}>\n        <FormControl>\n          <SelectTrigger>\n            <SelectValue placeholder=\"Sélectionner un canal\" />\n          </SelectTrigger>\n        </FormControl>\n        <SelectContent>\n          <SelectItem value=\"whatsapp\">WhatsApp</SelectItem>\n          <SelectItem value=\"sms\">SMS</SelectItem>\n          <SelectItem value=\"leboncoin\">Leboncoin</SelectItem>\n        </SelectContent>\n      </Select>\n      <FormMessage />\n    </FormItem>\n  )}\n/>\n```\n\nRefactor `src/components/templates/voice-template-form.tsx`:\n\n1. Use voiceTemplateClientSchema for client validation\n2. Handle Blob validation specially since it can't be in react-hook-form directly:\n```typescript\nconst [audioBlob, setAudioBlob] = useState<Blob | null>(null);\n// Validate blob separately before submit\n```\n\n3. Maintain audio preview functionality while using form state",
        "testStrategy": "1. Test text template form validation errors display correctly\n2. Test channel selection works with shadcn Select\n3. Test variable insertion still works with form state\n4. Test live preview updates correctly\n5. Test voice template duration validation (15-55s)\n6. Test voice template requires audio file before submit\n7. Test both forms submit successfully with valid data\n8. Verify isDefault checkbox works correctly",
        "priority": "high",
        "dependencies": [
          "17",
          "19"
        ],
        "status": "in-progress",
        "subtasks": [],
        "updatedAt": "2026-01-22T19:14:43.416Z"
      },
      {
        "id": "24",
        "title": "Add Server-Side Validation to Template Actions",
        "description": "Add Zod schema validation to createTextTemplate and createVoiceTemplate server actions for consistent validation.",
        "details": "Update `src/actions/template.actions.ts`:\n\n1. Import schemas:\n```typescript\nimport { textTemplateSchema, voiceTemplateSchema } from '@/schemas/validation/template.validation';\n```\n\n2. Update createTextTemplate:\n```typescript\nexport async function createTextTemplate(data: unknown) {\n  const supabase = await createClient();\n  const { data: { session } } = await supabase.auth.getSession();\n\n  if (!session) {\n    throw new Error('Non autorisé');\n  }\n\n  // Validate with Zod\n  const parseResult = textTemplateSchema.safeParse(data);\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const validatedData = parseResult.data;\n  // ... rest using validatedData.name, validatedData.channel, etc.\n}\n```\n\n3. Update createVoiceTemplate similarly with voiceTemplateSchema\n\n4. Remove redundant manual validation checks that are now handled by Zod:\n```typescript\n// Remove this:\nif (!data.name.trim() || !data.content.trim()) {\n  throw new Error('Name and content are required');\n}\n// Zod handles it now\n```\n\n5. Ensure error messages match the French messages from schemas",
        "testStrategy": "1. Test createTextTemplate rejects missing name/content with French errors\n2. Test createTextTemplate rejects invalid channel values\n3. Test createVoiceTemplate rejects invalid duration (<15s or >55s)\n4. Test createVoiceTemplate rejects missing audioUrl\n5. Test valid data passes validation and creates template\n6. Verify server validation catches attempts to bypass client validation",
        "priority": "high",
        "dependencies": [
          "19"
        ],
        "status": "done",
        "subtasks": [],
        "updatedAt": "2026-01-22T19:03:16.611Z"
      },
      {
        "id": "25",
        "title": "Refactor Lead Drawer Forms with react-hook-form and Zod",
        "description": "Refactor the notes and reminders forms in LeadDrawer component to use react-hook-form with Zod validation.",
        "details": "Update `src/components/leads/lead-drawer.tsx`:\n\n1. Create separate form instances for notes and reminders:\n```typescript\nimport { useForm } from 'react-hook-form';\nimport { zodResolver } from '@hookform/resolvers/zod';\nimport { \n  leadNoteSchema, \n  leadReminderSchema,\n  type LeadNoteFormData,\n  type LeadReminderFormData \n} from '@/schemas/validation/lead.validation';\n\n// Notes form\nconst noteForm = useForm<LeadNoteFormData>({\n  resolver: zodResolver(leadNoteSchema),\n  defaultValues: { content: '' },\n});\n\n// Reminders form\nconst reminderForm = useForm<LeadReminderFormData>({\n  resolver: zodResolver(leadReminderSchema),\n  defaultValues: { dueAt: '', note: '' },\n});\n```\n\n2. Replace notes form section:\n```typescript\n<Form {...noteForm}>\n  <form onSubmit={noteForm.handleSubmit(handleAddNote)} className=\"space-y-2\">\n    <FormField\n      control={noteForm.control}\n      name=\"content\"\n      render={({ field }) => (\n        <FormItem>\n          <FormControl>\n            <Textarea\n              placeholder=\"Ajouter une note...\"\n              rows={3}\n              {...field}\n            />\n          </FormControl>\n          <FormMessage />\n        </FormItem>\n      )}\n    />\n    <Button type=\"submit\" disabled={noteForm.formState.isSubmitting}>\n      {noteForm.formState.isSubmitting ? 'Enregistrement...' : 'Sauvegarder'}\n    </Button>\n  </form>\n</Form>\n```\n\n3. Replace reminders form similarly with datetime-local input\n\n4. Reset forms after successful submission:\n```typescript\nconst handleAddNote = async (data: LeadNoteFormData) => {\n  try {\n    await addLeadNote(lead.id, data.content);\n    noteForm.reset();\n    // ... reload lead\n  } catch (err) {\n    noteForm.setError('root', { message: err.message });\n  }\n};\n```\n\n5. Remove separate error state variables (noteError, reminderError) - use form state instead",
        "testStrategy": "1. Test note form validation rejects empty content\n2. Test note form shows error message inline\n3. Test reminder form validates future date requirement\n4. Test reminder form accepts valid future date\n5. Test forms reset after successful submission\n6. Test submission loading states display correctly\n7. Test error handling displays errors from server actions",
        "priority": "medium",
        "dependencies": [
          "17",
          "20"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "26",
        "title": "Add Server-Side Validation to Lead Actions",
        "description": "Add Zod schema validation to addLeadNote and addLeadReminder server actions.",
        "details": "Update `src/actions/lead.actions.ts`:\n\n1. Import schemas:\n```typescript\nimport { leadNoteSchema, leadReminderSchema } from '@/schemas/validation/lead.validation';\n```\n\n2. Update addLeadNote:\n```typescript\nexport async function addLeadNote(leadId: string, content: unknown) {\n  // ... auth check\n\n  // Validate content\n  const parseResult = leadNoteSchema.safeParse({ content });\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const validatedContent = parseResult.data.content;\n  // ... rest of function\n}\n```\n\n3. Update addLeadReminder:\n```typescript\nexport async function addLeadReminder(\n  leadId: string,\n  dueAt: unknown,\n  note?: unknown,\n) {\n  // ... auth check\n\n  // Validate reminder data\n  const parseResult = leadReminderSchema.safeParse({ dueAt, note });\n  if (!parseResult.success) {\n    throw new Error(formatZodError(parseResult.error));\n  }\n\n  const { dueAt: validatedDueAt, note: validatedNote } = parseResult.data;\n  // ... rest of function using validated values\n}\n```\n\n4. Remove manual validation that's now handled by Zod:\n```typescript\n// Remove:\nif (!content.trim()) {\n  throw new Error('Note content cannot be empty');\n}\n// Zod handles this\n```",
        "testStrategy": "1. Test addLeadNote rejects empty content with French error\n2. Test addLeadReminder rejects past dates with French error\n3. Test valid note content is accepted\n4. Test valid future reminder date is accepted\n5. Test optional reminder note field works correctly\n6. Verify server catches validation bypass attempts",
        "priority": "medium",
        "dependencies": [
          "20"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "27",
        "title": "Apply shadcn/ui Component Styling Consistency",
        "description": "Replace remaining custom form elements with shadcn/ui components across all refactored forms to ensure consistent styling and behavior.",
        "details": "Review and update all form components to use shadcn/ui consistently:\n\n1. **Buttons**: Replace custom button styles with shadcn Button:\n```typescript\nimport { Button } from '@/components/ui/button';\n\n// Replace:\n<button className=\"flex-1 rounded-lg bg-amber-500...\">\n// With:\n<Button variant=\"default\" className=\"flex-1\">\n```\n\nMay need to customize button variants in button.tsx to match amber theme.\n\n2. **Input fields**: All text inputs should use shadcn Input\n3. **Textareas**: Use shadcn Textarea component\n4. **Checkboxes**: Use shadcn Checkbox with proper labeling:\n```typescript\n<FormField\n  control={form.control}\n  name=\"autoRefresh\"\n  render={({ field }) => (\n    <FormItem className=\"flex items-center gap-3\">\n      <FormControl>\n        <Checkbox\n          checked={field.value}\n          onCheckedChange={field.onChange}\n        />\n      </FormControl>\n      <div>\n        <FormLabel>Rafraîchissement automatique</FormLabel>\n        <FormDescription>\n          Recherche automatiquement de nouvelles annonces tous les jours\n        </FormDescription>\n      </div>\n    </FormItem>\n  )}\n/>\n```\n\n5. **Select dropdowns**: Use shadcn Select for channel selection and similar\n\n6. **Error messages**: Ensure all use FormMessage for consistent error display\n\n7. **Theme consistency**: Update shadcn components' CSS variables in globals.css to match the existing zinc/amber dark theme",
        "testStrategy": "1. Visual inspection of all forms for consistent styling\n2. Test all interactive elements (buttons, checkboxes, selects) work correctly\n3. Verify dark theme (zinc/amber) is maintained across all shadcn components\n4. Test focus states and accessibility (keyboard navigation)\n5. Verify error message styling is consistent\n6. Test on different screen sizes for responsive behavior",
        "priority": "medium",
        "dependencies": [
          "21",
          "23",
          "25"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "28",
        "title": "Create Barrel Export and Documentation for Validation Schemas",
        "description": "Create a proper barrel export file for all validation schemas and add inline documentation for schema usage patterns.",
        "details": "Create/update `src/schemas/validation/index.ts`:\n\n```typescript\n/**\n * Centralized validation schemas for Auto-Prospect\n * \n * These schemas are used for both client-side (react-hook-form) and \n * server-side (server actions) validation to ensure consistent validation.\n * \n * Usage in components:\n * ```typescript\n * import { huntFormSchema, type HuntFormData } from '@/schemas/validation';\n * \n * const form = useForm<HuntFormData>({\n *   resolver: zodResolver(huntFormSchema),\n * });\n * ```\n * \n * Usage in server actions:\n * ```typescript\n * import { createHuntSchema } from '@/schemas/validation';\n * \n * const result = createHuntSchema.safeParse(data);\n * if (!result.success) throw new Error(formatZodError(result.error));\n * ```\n */\n\n// Hunt schemas\nexport {\n  huntFormSchema,\n  createHuntSchema,\n  type HuntFormData,\n  type CreateHuntData,\n} from './hunt.validation';\n\n// Template schemas\nexport {\n  textTemplateSchema,\n  voiceTemplateSchema,\n  voiceTemplateClientSchema,\n  type TextTemplateFormData,\n  type VoiceTemplateFormData,\n  type VoiceTemplateClientData,\n} from './template.validation';\n\n// Lead schemas\nexport {\n  leadNoteSchema,\n  leadReminderSchema,\n  type LeadNoteFormData,\n  type LeadReminderFormData,\n} from './lead.validation';\n\n// Settings schemas\nexport {\n  teamInvitationSchema,\n  organizationSettingsSchema,\n  type TeamInvitationFormData,\n  type OrganizationSettingsFormData,\n} from './settings.validation';\n```\n\nAdd a shared utility for formatting Zod errors:\n```typescript\n// src/lib/validation.ts\nimport { z } from 'zod';\n\nexport function formatZodError(error: z.ZodError): string {\n  const fieldErrors = error.flatten().fieldErrors;\n  const firstError = Object.values(fieldErrors).flat()[0];\n  return firstError || 'Données de formulaire invalides';\n}\n```",
        "testStrategy": "1. Verify all exports are accessible from '@/schemas/validation'\n2. Test importing individual schemas works\n3. Test type imports work correctly\n4. Verify formatZodError utility returns French error messages\n5. Check no circular dependencies exist",
        "priority": "low",
        "dependencies": [
          "18",
          "19",
          "20"
        ],
        "status": "pending",
        "subtasks": []
      },
      {
        "id": "29",
        "title": "End-to-End Form Validation Testing",
        "description": "Perform comprehensive end-to-end testing of all refactored forms including client validation, server validation, and error display.",
        "details": "Create a comprehensive testing checklist and execute manual E2E tests:\n\n**Hunt Form Tests:**\n1. Submit empty form → Verify French error for name field\n2. Enter name only, submit → Verify URL error (if URL tab active)\n3. Enter valid data → Verify successful creation and redirect\n4. Test edit mode with pre-filled data\n5. Disable JS and submit → Verify server catches validation\n\n**Text Template Form Tests:**\n1. Submit empty form → Verify name and content errors\n2. Test channel dropdown selection\n3. Test variable insertion still works\n4. Test live preview updates\n5. Submit valid form → Verify redirect to templates\n\n**Voice Template Form Tests:**\n1. Submit without audio → Verify audio required error\n2. Upload <15s audio → Verify duration error\n3. Upload >55s audio → Verify duration error\n4. Record valid audio → Verify submission works\n\n**Lead Drawer Tests:**\n1. Submit empty note → Verify error inline\n2. Submit valid note → Verify note added, form reset\n3. Add reminder with past date → Verify error\n4. Add reminder with future date → Verify success\n5. Delete reminder → Verify removed\n\n**Cross-cutting Tests:**\n1. All error messages in French\n2. Form loading states display correctly\n3. Errors clear when user starts typing\n4. Form state persists across tab switches (hunt form)\n5. Accessibility: keyboard navigation, screen reader",
        "testStrategy": "Execute each test case manually:\n1. Open each form in the browser\n2. Test each validation scenario\n3. Verify error messages match expected French text\n4. Check browser console for any JS errors\n5. Test with network throttling for loading states\n6. Document any failures for fixing\n7. Re-test after fixes until all pass",
        "priority": "high",
        "dependencies": [
          "21",
          "22",
          "23",
          "24",
          "25",
          "26",
          "27"
        ],
        "status": "pending",
        "subtasks": []
      }
    ],
    "metadata": {
      "version": "1.0.0",
      "lastModified": "2026-01-22T19:14:43.417Z",
      "taskCount": 29,
      "completedCount": 22,
      "tags": [
        "master"
      ]
    }
  }
}